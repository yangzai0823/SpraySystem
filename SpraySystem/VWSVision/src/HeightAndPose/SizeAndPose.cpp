///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 20.11.3.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (utf8).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
//
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
//
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#ifndef __APPLE__
#include "halconcpp/HalconCpp.h"
#include "halconcpp/HDevThread.h"
#else
#ifndef HC_LARGE_IMAGES
#include <HALCONCpp/HalconCpp.h>
#include <HALCONCpp/HDevThread.h>
#else
#include <HALCONCppxl/HalconCpp.h>
#include <HALCONCppxl/HDevThread.h>
#endif
#endif

#include <iostream>
#include "SizeAndPose.h"
// #include <Eigen/Dense>

using namespace HalconCpp;
// // using namespace Eigen;
// using namespace std;

namespace PCLlibs
{
    // Procedure declarations
    void CalCenterLinePoints(HTuple hv_LeftUp, HTuple hv_LeftDown, HTuple hv_RightUp,
                             HTuple hv_RightDown, HTuple hv_MeasureWidth, HTuple *hv_Rows, HTuple *hv_Columns,
                             HTuple *hv_tuple_Phi, HTuple *hv_tuple_Len1, HTuple *hv_tuple_Len2);
    void CalcuCornerPoint(HObject ho_RegionFillUp, HObject ho_ImageReduced1, HObject ho_ImageReduced2,
                          HObject ho_ImageReduced3, HTuple hv_RightUp, HTuple *hv_LeftUpPoint);
    void CalMeanPoint(HTuple hv_MatW, HTuple hv_LineUpX, HTuple *hv_meanX);
    void CrossMultFunc(HTuple hv_N, HTuple hv_N1, HTuple *hv_VectorCross);
    // Chapter: Graphics / Output
    // Short Description: Determine the optimum distance of the object to obtain a reasonable visualization
    void determine_optimum_pose_distance(HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
                                         HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut);
    void distance_3d_pp(HTuple hv_point1, HTuple hv_point2, HTuple *hv_Distance3DPP);
    void DotVector(HTuple hv_lineVecUp, HTuple hv_lineVecRight, HTuple *hv_DotA);
    void FitLine3D(HTuple hv_LineUpX, HTuple hv_LineUpY, HTuple hv_LineUpZ, HTuple *hv_MeanPoint1,
                   HTuple *hv_lineVec1);
    void fitLine_wls(HTuple hv_MatA, HTuple hv_MatW, HTuple *hv_MeanPoint, HTuple *hv_lineVec);
    // Chapter: Calibration / Camera Parameters
    // Short Description: Get the value of a specified camera parameter from the camera parameter tuple.
    void get_cam_par_data(HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue);
    // Chapter: Calibration / Camera Parameters
    // Short Description: Get the names of the parameters in a camera parameter tuple.
    void get_cam_par_names(HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames);
    // Chapter: Graphics / Output
    // Short Description: Compute the center of all given 3D object models.
    void get_object_models_center(HTuple hv_ObjectModel3DID, HTuple *hv_Center);
    void get_object_pose(HTuple hv_ObjectModel3DRigidTrans, HTuple hv_CamParam, HTuple *hv_Pose2);
    void getWLSWeight(HTuple hv_MatA, HTuple hv_MeanPoint, HTuple hv_lineVec, HTuple *hv_MatW2);
    void HeightAndPoseVector(HTuple hv_CamParam, double hv_SetParas[6], HTuple hv_ObjectModel3D, double &MedianHeight, double &MedianWidth, double *VectorPosition, double *IntersecPonitUR,
                             double *IntersecPonitUL, double *IntersecPonitDR, double *IntersecPonitDL, double *LineQuali, std::string &Result);
    void LineIntersec3D(HTuple hv_MeanPointUp, HTuple hv_lineVecUp, HTuple hv_MeanPointRight,
                        HTuple hv_lineVecRight, HTuple *hv_IntersecPonit, int *hv_Result);
    void LineQuality_3D(HTuple hv_LineUpX, HTuple hv_LineUpY, HTuple hv_LineUpZ, HTuple hv_MeanPointUp,
                        HTuple hv_lineVecUp, HTuple *hv_DistUp, HTuple *hv_MedianUp, HTuple *hv_DeviationUp);
    void MeasureHeight(HObject ho_RegionFillUp, HObject ho_ImageReduced1, HObject ho_ImageReduced2,
                       HObject ho_ImageReduced3, HObject ho_ZResult, HObject ho_Rectangle, HTuple hv_Rows,
                       HTuple hv_Columns, HTuple hv_tuple_Phi, HTuple hv_tuple_Len1, HTuple hv_tuple_Len2,
                       HTuple hv_MaxTh, HTuple hv_MinTh, HTuple *hv_Height3D, HTuple *hv_LineUpX, HTuple *hv_LineUpY,
                       HTuple *hv_LineUpZ, HTuple *hv_LineDownX, HTuple *hv_LineDownY, HTuple *hv_LineDownZ);
    void Rect2Corner(HTuple hv_CenterY, HTuple hv_CenterX, HTuple hv_Phi, HTuple hv_Len1,
                     HTuple hv_Len2, HTuple *hv_CornerY, HTuple *hv_CornerX);
    void SortCorner(HTuple hv_RightUpPoint, HTuple hv_RightUpPoint2, HTuple hv_RightDownPoint2,
                    HTuple hv_LeftUpPoint2, HTuple hv_LeftDownPoint2, HTuple hv_RightDown1, HTuple hv_RightUp1,
                    HTuple hv_LeftUp1, HTuple hv_LeftDown1, HTuple *hv_RightUp);
    void UnitVector(HTuple hv_LeftUpPoint, HTuple hv_LeftDownPoint, HTuple *hv_LeftUnitVec);
    void VectorPoint_3rd_trans(HTuple hv_HomMat3D, HTuple hv_HomMat3D1, HTuple hv_HomMat3D2,
                               HTuple hv_RightUpPoint1, HTuple *hv_RightUpPoint);
    void VectorPoints_3rd_trans(HTuple hv_LineUpX1, HTuple hv_LineUpY1, HTuple hv_LineUpZ1,
                                HTuple hv_HomMat3D, HTuple hv_HomMat3D1, HTuple hv_HomMat3D2, HTuple *hv_LineUpX,
                                HTuple *hv_LineUpY, HTuple *hv_LineUpZ);
    void CalBoxDeepth(double SensorDis, double SensorDis1, double SensorDis2, double holeDis, double MatRot[9], double NormalVec[3], double &deepth);
    //-------------------------------------------------------Calculate Box Length
    void Cal2Norm(HTuple hv_RightLineVector, HTuple *hv_NormS2);
    void CalBoxLength(double Vector[3], double s2, double s1, double LeftUpPoint[3],
                      double LeftDownPoint[3], double RightUpPoint[3], double RightDownPoint[3], double &boxLength);

    void Distance_point_line_3d(HTuple hv_RightUpPoint, HTuple hv_RightLineVector, HTuple hv_LeftUpPoint1,
                                HTuple *hv_Distan1);

    void Line3D_Angle(HTuple hv_lineVecRight, HTuple hv_lineVecUp, HTuple *hv_AngleUR);

    void CalcuCameraRobot(double VectorX[3], double VectorY[3], double VectorZ[3], double RightUpPoint[3],
                          double boxSize[3], double VectorX1[3], double VectorY1[3], double VectorZ1[3], double CalibPoint[3], double *Quater, double *CenterPoint);
    void CalcuCameraRobot(double VectorX[3], double VectorY[3], double VectorZ[3], double RightUpPoint[3],
                          double boxSize[3], double CalibPose[12], double *Quater, double *CenterPoint);
    void CalcuCameraRobot(double VectorPosition[9], double RightUpPoint[3], double boxSize[3], double CalibPose[12], double *Quater, double *CenterPoint);

    // Procedures
    void CalcuCameraRobot(double VectorX[3], double VectorY[3], double VectorZ[3], double RightUpPoint[3],
                          double boxSize[3], double VectorX1[3], double VectorY1[3], double VectorZ1[3], double CalibPoint[3], double *Quater, double *CenterPoint)
    {

        // Local control variables
        HTuple hv_VectorX, hv_VectorY, hv_VectorZ;
        HTuple hv_RightPoint, hv_Size;
        HTuple hv_VectorX1, hv_VectorY1, hv_VectorZ1, hv_calibPoint;
        HTuple hv_ProdX, hv_ProdY, hv_Sum1, hv_ProdZ;
        HTuple hv_Sum2, hv_Trans, hv_HomMat3DIdentity, hv_HomMat3DTranslate2;
        HTuple hv_Pose3, hv_HomMatCamera, hv_HomMat3DIdentity1;
        HTuple hv_Pose, hv_HomMatCalib, hv_HomMat3DCompose, hv_HomMat3DTranslate;
        HTuple hv_Quaternion, hv_Pose1;
        hv_VectorX.Clear();
        hv_VectorY.Clear();
        hv_VectorZ.Clear();
        hv_RightPoint.Clear();
        hv_Size.Clear();
        hv_VectorX1.Clear();
        hv_VectorY1.Clear();
        hv_VectorZ1.Clear();
        hv_calibPoint.Clear();
        hv_VectorX[0] = VectorX[0];
        hv_VectorX[1] = VectorX[1];
        hv_VectorX[2] = VectorX[2];
        hv_VectorY[0] = VectorY[0];
        hv_VectorY[1] = VectorY[1];
        hv_VectorY[2] = VectorY[2];
        hv_VectorZ[0] = VectorZ[0];
        hv_VectorZ[1] = VectorZ[1];
        hv_VectorZ[2] = VectorZ[2];
        hv_RightPoint[0] = RightUpPoint[0];
        hv_RightPoint[1] = RightUpPoint[1];
        hv_RightPoint[2] = RightUpPoint[2];
        hv_Size[0] = boxSize[0];
        hv_Size[1] = boxSize[1];
        hv_Size[2] = boxSize[2];
        hv_VectorX1[0] = VectorX1[0];
        hv_VectorX1[1] = VectorX1[1];
        hv_VectorX1[2] = VectorX1[2];
        hv_VectorY1[0] = VectorY1[0];
        hv_VectorY1[1] = VectorY1[1];
        hv_VectorY1[2] = VectorY1[2];
        hv_VectorZ1[0] = VectorZ1[0];
        hv_VectorZ1[1] = VectorZ1[1];
        hv_VectorZ1[2] = VectorZ1[2];
        hv_calibPoint[0] = CalibPoint[0];
        hv_calibPoint[1] = CalibPoint[1];
        hv_calibPoint[2] = CalibPoint[2];
        TupleMult(-hv_VectorZ, HTuple(hv_Size[0]) / 2, &hv_ProdX);
        TupleMult(-hv_VectorY, HTuple(hv_Size[1]) / 2, &hv_ProdY);
        TupleAdd(hv_ProdX, hv_ProdY, &hv_Sum1);
        TupleMult(-hv_VectorX, HTuple(hv_Size[2]) / 2, &hv_ProdZ);
        TupleAdd(hv_Sum1, hv_ProdZ, &hv_Sum2);
        TupleAdd(hv_Sum2, hv_RightPoint, &hv_Trans);

        //*----------------------------------显示棱向量和法向量
        HomMat3dIdentity(&hv_HomMat3DIdentity);
        HomMat3dTranslate(hv_HomMat3DIdentity, HTuple(hv_Trans[0]), HTuple(hv_Trans[1]),
                          HTuple(hv_Trans[2]), &hv_HomMat3DTranslate2);

        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(0, 2, 1)] = (HTuple(hv_VectorX[0]).TupleConcat(HTuple(hv_VectorY[0]))).TupleConcat(HTuple(hv_VectorZ[0]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(4, 6, 1)] = (HTuple(hv_VectorX[1]).TupleConcat(HTuple(hv_VectorY[1]))).TupleConcat(HTuple(hv_VectorZ[1]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(8, 10, 1)] = (HTuple(hv_VectorX[2]).TupleConcat(HTuple(hv_VectorY[2]))).TupleConcat(HTuple(hv_VectorZ[2]));
        HomMat3dToPose(hv_HomMat3DTranslate2, &hv_Pose3);
        PoseToHomMat3d(hv_Pose3, &hv_HomMatCamera);

        HomMat3dIdentity(&hv_HomMat3DIdentity1);
        HomMat3dTranslate(hv_HomMat3DIdentity1, HTuple(hv_calibPoint[0]), HTuple(hv_calibPoint[1]),
                          HTuple(hv_calibPoint[2]), &hv_HomMat3DTranslate);
        hv_HomMat3DTranslate[HTuple::TupleGenSequence(0, 2, 1)] = (HTuple(hv_VectorX1[0]).TupleConcat(HTuple(hv_VectorY1[0]))).TupleConcat(HTuple(hv_VectorZ1[0]));
        hv_HomMat3DTranslate[HTuple::TupleGenSequence(4, 6, 1)] = (HTuple(hv_VectorX1[1]).TupleConcat(HTuple(hv_VectorY1[1]))).TupleConcat(HTuple(hv_VectorZ1[1]));
        hv_HomMat3DTranslate[HTuple::TupleGenSequence(8, 10, 1)] = (HTuple(hv_VectorX1[2]).TupleConcat(HTuple(hv_VectorY1[2]))).TupleConcat(HTuple(hv_VectorZ1[2]));
        HomMat3dToPose(hv_HomMat3DTranslate, &hv_Pose);
        PoseToHomMat3d(hv_Pose, &hv_HomMatCalib);

        HomMat3dCompose(hv_HomMatCalib, hv_HomMatCamera, &hv_HomMat3DCompose);

        //     hv_HomMat3DIdentity1[HTuple::TupleGenSequence(0, 2, 1)] = (HTuple(hv_VectorX1[0]).TupleConcat(HTuple(hv_VectorY1[0]))).TupleConcat(HTuple(hv_VectorZ1[0]));
        //     hv_HomMat3DIdentity1[HTuple::TupleGenSequence(4, 6, 1)] = (HTuple(hv_VectorX1[1]).TupleConcat(HTuple(hv_VectorY1[1]))).TupleConcat(HTuple(hv_VectorZ1[1]));
        //     hv_HomMat3DIdentity1[HTuple::TupleGenSequence(8, 10, 1)] = (HTuple(hv_VectorX1[2]).TupleConcat(HTuple(hv_VectorY1[2]))).TupleConcat(HTuple(hv_VectorZ1[2]));
        //     HomMat3dToPose(hv_HomMat3DIdentity1, &hv_Pose);
        //     PoseToHomMat3d(hv_Pose, &hv_HomMatCalib);
        //   HomMat3dTranslate (hv_HomMatCalib, HTuple(hv_calibPoint[0]), HTuple(hv_calibPoint[1]),
        //                       HTuple(hv_calibPoint[2]), &hv_HomMat3DTranslate3);
        //     HomMat3dCompose(hv_HomMat3DTranslate3, hv_HomMatCamera, &hv_HomMat3DCompose);
        HomMat3dToPose(hv_HomMat3DCompose, &hv_Pose1);
        PoseToQuat(hv_Pose1, &hv_Quaternion);

        double *tmpQuater = hv_Quaternion.ToDArr();
        Quater[0] = tmpQuater[0];
        Quater[1] = tmpQuater[1];
        Quater[2] = tmpQuater[2];
        Quater[3] = tmpQuater[3];

        double *tmpPoint = hv_HomMat3DCompose.ToDArr();
        CenterPoint[0] = tmpPoint[3];
        CenterPoint[1] = tmpPoint[7];
        CenterPoint[2] = tmpPoint[11];
        return;
    }

    void CalcuCameraRobot(double VectorX[3], double VectorY[3], double VectorZ[3], double RightUpPoint[3],
                          double boxSize[3], double CalibPose[12], double *Quater, double *CenterPoint)
    {

        // Local control variables
        HTuple hv_VectorX, hv_VectorY, hv_VectorZ;
        HTuple hv_RightPoint, hv_Size;
        HTuple hv_calibPose;
        // HTuple hv_VectorX1, hv_VectorY1, hv_VectorZ1, hv_calibPoint;
        HTuple hv_ProdX, hv_ProdY, hv_Sum1, hv_ProdZ;
        HTuple hv_Sum2, hv_Trans, hv_HomMat3DIdentity, hv_HomMat3DTranslate2;
        HTuple hv_Pose3, hv_HomMatCamera, hv_HomMat3DIdentity1;
        HTuple hv_Pose, hv_HomMatCalib, hv_HomMat3DCompose, hv_HomMat3DTranslate;
        HTuple hv_Quaternion, hv_Pose1;
        hv_VectorX.Clear();
        hv_VectorY.Clear();
        hv_VectorZ.Clear();
        hv_RightPoint.Clear();
        hv_Size.Clear();
        // hv_VectorX1.Clear();
        // hv_VectorY1.Clear();
        // hv_VectorZ1.Clear();
        // hv_calibPoint.Clear();
        hv_VectorX[0] = VectorX[0];
        hv_VectorX[1] = VectorX[1];
        hv_VectorX[2] = VectorX[2];
        hv_VectorY[0] = VectorY[0];
        hv_VectorY[1] = VectorY[1];
        hv_VectorY[2] = VectorY[2];
        hv_VectorZ[0] = VectorZ[0];
        hv_VectorZ[1] = VectorZ[1];
        hv_VectorZ[2] = VectorZ[2];
        hv_RightPoint[0] = RightUpPoint[0];
        hv_RightPoint[1] = RightUpPoint[1];
        hv_RightPoint[2] = RightUpPoint[2];
        hv_Size[0] = boxSize[0];
        hv_Size[1] = boxSize[1];
        hv_Size[2] = boxSize[2];
        hv_calibPose[0] = CalibPose[0];
        hv_calibPose[1] = CalibPose[1];
        hv_calibPose[2] = CalibPose[2];
        hv_calibPose[3] = CalibPose[3];
        hv_calibPose[4] = CalibPose[4];
        hv_calibPose[5] = CalibPose[5];
        hv_calibPose[6] = CalibPose[6];
        hv_calibPose[7] = CalibPose[7];
        hv_calibPose[8] = CalibPose[8];
        hv_calibPose[9] = CalibPose[9];
        hv_calibPose[10] = CalibPose[10];
        hv_calibPose[11] = CalibPose[11];
        TupleMult(-hv_VectorZ, HTuple(hv_Size[0]) / 2, &hv_ProdX);
        TupleMult(-hv_VectorY, HTuple(hv_Size[1]) / 2, &hv_ProdY);
        TupleAdd(hv_ProdX, hv_ProdY, &hv_Sum1);
        TupleMult(-hv_VectorX, HTuple(hv_Size[2]) / 2, &hv_ProdZ);
        TupleAdd(hv_Sum1, hv_ProdZ, &hv_Sum2);
        TupleAdd(hv_Sum2, hv_RightPoint, &hv_Trans);

        //*----------------------------------
        HomMat3dIdentity(&hv_HomMat3DIdentity);
        HomMat3dTranslate(hv_HomMat3DIdentity, HTuple(hv_Trans[0]), HTuple(hv_Trans[1]),
                          HTuple(hv_Trans[2]), &hv_HomMat3DTranslate2);
        // hv_HomMat3DTranslate2[HTuple::TupleGenSequence(0, 11, 1)]=HTuple(hv_calibPose);
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(0, 2, 1)] = (HTuple(hv_VectorX[0]).TupleConcat(HTuple(hv_VectorY[0]))).TupleConcat(HTuple(hv_VectorZ[0]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(4, 6, 1)] = (HTuple(hv_VectorX[1]).TupleConcat(HTuple(hv_VectorY[1]))).TupleConcat(HTuple(hv_VectorZ[1]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(8, 10, 1)] = (HTuple(hv_VectorX[2]).TupleConcat(HTuple(hv_VectorY[2]))).TupleConcat(HTuple(hv_VectorZ[2]));
        HomMat3dToPose(hv_HomMat3DTranslate2, &hv_Pose3);
        PoseToHomMat3d(hv_Pose3, &hv_HomMatCamera);

        HomMat3dIdentity(&hv_HomMat3DIdentity1);
        hv_HomMat3DIdentity1[HTuple::TupleGenSequence(0, 11, 1)] = HTuple(hv_calibPose);
        HomMat3dToPose(hv_HomMat3DIdentity1, &hv_Pose);
        PoseToHomMat3d(hv_Pose, &hv_HomMatCalib);

        HomMat3dCompose(hv_HomMatCalib, hv_HomMatCamera, &hv_HomMat3DCompose);

        HomMat3dToPose(hv_HomMat3DCompose, &hv_Pose1);
        PoseToQuat(hv_Pose1, &hv_Quaternion);

        double *tmpQuater = hv_Quaternion.ToDArr();
        Quater[0] = tmpQuater[0];
        Quater[1] = tmpQuater[1];
        Quater[2] = tmpQuater[2];
        Quater[3] = tmpQuater[3];

        double *tmpPoint = hv_HomMat3DCompose.ToDArr();
        CenterPoint[0] = tmpPoint[3];
        CenterPoint[1] = tmpPoint[7];
        CenterPoint[2] = tmpPoint[11];
        return;
    }

    void CalcuCameraRobot(double VectorPosition[9], double RightUpPoint[3], double boxSize[3], double CalibPose[12], double *Quater, double *CenterPoint)
    {
        CenterPoint[0] = 0;
        CenterPoint[1] = 0;
        CenterPoint[2] = 0;
        Quater[0] = 0;
        Quater[1] = 0;
        Quater[2] = 0;
        Quater[3] = 0;
        // Local control variables
        HTuple hv_VectorX, hv_VectorY, hv_VectorZ;
        HTuple hv_RightPoint, hv_Size;
        HTuple hv_calibPose;
        // HTuple hv_VectorX1, hv_VectorY1, hv_VectorZ1, hv_calibPoint;
        HTuple hv_ProdX, hv_ProdY, hv_Sum1, hv_ProdZ;
        HTuple hv_Sum2, hv_Trans, hv_HomMat3DIdentity, hv_HomMat3DTranslate2;
        HTuple hv_Pose3, hv_HomMatCamera, hv_HomMat3DIdentity1;
        HTuple hv_Pose, hv_HomMatCalib, hv_HomMat3DCompose, hv_HomMat3DTranslate;
        HTuple hv_Quaternion, hv_Pose1;
        hv_VectorX.Clear();
        hv_VectorY.Clear();
        hv_VectorZ.Clear();
        hv_RightPoint.Clear();
        hv_Size.Clear();
        // hv_VectorX1.Clear();
        // hv_VectorY1.Clear();
        // hv_VectorZ1.Clear();
        // hv_calibPoint.Clear();
        hv_VectorX[0] = VectorPosition[0];
        hv_VectorX[1] = VectorPosition[1];
        hv_VectorX[2] = VectorPosition[2];
        hv_VectorY[0] = VectorPosition[3];
        hv_VectorY[1] = VectorPosition[4];
        hv_VectorY[2] = VectorPosition[5];
        hv_VectorZ[0] = VectorPosition[6];
        hv_VectorZ[1] = VectorPosition[7];
        hv_VectorZ[2] = VectorPosition[8];
        hv_RightPoint[0] = RightUpPoint[0];
        hv_RightPoint[1] = RightUpPoint[1];
        hv_RightPoint[2] = RightUpPoint[2];
        hv_Size[0] = boxSize[0];
        hv_Size[1] = boxSize[1];
        hv_Size[2] = boxSize[2];
        hv_calibPose[0] = CalibPose[0];
        hv_calibPose[1] = CalibPose[1];
        hv_calibPose[2] = CalibPose[2];
        hv_calibPose[3] = CalibPose[3];
        hv_calibPose[4] = CalibPose[4];
        hv_calibPose[5] = CalibPose[5];
        hv_calibPose[6] = CalibPose[6];
        hv_calibPose[7] = CalibPose[7];
        hv_calibPose[8] = CalibPose[8];
        hv_calibPose[9] = CalibPose[9];
        hv_calibPose[10] = CalibPose[10];
        hv_calibPose[11] = CalibPose[11];
        TupleMult(-hv_VectorZ, HTuple(hv_Size[0]) / 2, &hv_ProdX);
        TupleMult(-hv_VectorY, HTuple(hv_Size[1]) / 2, &hv_ProdY);
        TupleAdd(hv_ProdX, hv_ProdY, &hv_Sum1);
        TupleMult(-hv_VectorX, HTuple(hv_Size[2]) / 2, &hv_ProdZ);
        TupleAdd(hv_Sum1, hv_ProdZ, &hv_Sum2);
        TupleAdd(hv_Sum2, hv_RightPoint, &hv_Trans);

        //*----------------------------------
        HomMat3dIdentity(&hv_HomMat3DIdentity);
        HomMat3dTranslate(hv_HomMat3DIdentity, HTuple(hv_Trans[0]), HTuple(hv_Trans[1]),
                          HTuple(hv_Trans[2]), &hv_HomMat3DTranslate2);
        // hv_HomMat3DTranslate2[HTuple::TupleGenSequence(0, 11, 1)]=HTuple(hv_calibPose);
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(0, 2, 1)] = (HTuple(hv_VectorX[0]).TupleConcat(HTuple(hv_VectorY[0]))).TupleConcat(HTuple(hv_VectorZ[0]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(4, 6, 1)] = (HTuple(hv_VectorX[1]).TupleConcat(HTuple(hv_VectorY[1]))).TupleConcat(HTuple(hv_VectorZ[1]));
        hv_HomMat3DTranslate2[HTuple::TupleGenSequence(8, 10, 1)] = (HTuple(hv_VectorX[2]).TupleConcat(HTuple(hv_VectorY[2]))).TupleConcat(HTuple(hv_VectorZ[2]));
        HomMat3dToPose(hv_HomMat3DTranslate2, &hv_Pose3);
        PoseToHomMat3d(hv_Pose3, &hv_HomMatCamera);

        HomMat3dIdentity(&hv_HomMat3DIdentity1);
        hv_HomMat3DIdentity1[HTuple::TupleGenSequence(0, 11, 1)] = HTuple(hv_calibPose);
        HomMat3dToPose(hv_HomMat3DIdentity1, &hv_Pose);
        PoseToHomMat3d(hv_Pose, &hv_HomMatCalib);

        HomMat3dCompose(hv_HomMatCalib, hv_HomMatCamera, &hv_HomMat3DCompose);

        HomMat3dToPose(hv_HomMat3DCompose, &hv_Pose1);
        PoseToQuat(hv_Pose1, &hv_Quaternion);

        double *tmpQuater = hv_Quaternion.ToDArr();
        Quater[0] = tmpQuater[0];
        Quater[1] = tmpQuater[1];
        Quater[2] = tmpQuater[2];
        Quater[3] = tmpQuater[3];

        double *tmpPoint = hv_HomMat3DCompose.ToDArr();
        CenterPoint[0] = tmpPoint[3];
        CenterPoint[1] = tmpPoint[7];
        CenterPoint[2] = tmpPoint[11];
        return;
    }

    // Procedures
    void Cal2Norm(HTuple hv_RightLineVector, HTuple *hv_NormS2)
    {
        // Local iconic variables

        // Local control variables
        HTuple hv_Abs2, hv_Prod1, hv_NormS21;

        TupleAbs(hv_RightLineVector, &hv_Abs2);
        TupleMult(hv_Abs2, hv_Abs2, &hv_Prod1);
        TupleSum(hv_Prod1, &hv_NormS21);
        (*hv_NormS2) = hv_NormS21.TupleSqrt();
        return;
    }

    void CalBoxDeepth(double SensorDis, double SensorDis1, double SensorDis2, double holeDis, double MatRot[9], double NormalVec[3], double &deepth)
    {
        HTuple hv_Length, hv_D, hv_HomMat2DIdentity;
        HTuple hv_Vx, hv_Vy, hv_Vz, hv_Vector, hv_S1, hv_S2, hv_Width;
        HTuple hv_DVx, hv_WVz, hv_Sum, hv_VectorWidth, hv_Prod;
        HTuple hv_Sum1, hv_Deepth;
        double tmpDeep;
        hv_Length.Clear();
        hv_S1.Clear();
        hv_S2.Clear();
        hv_Length = HTuple(SensorDis);
        hv_S1 = HTuple(SensorDis1);
        hv_S2 = HTuple(SensorDis2);
        deepth = 0;
        //深度的直接测量结果为
        hv_Width = (hv_Length - hv_S1) - hv_S2;
        hv_D.Clear();
        hv_D = HTuple(holeDis);
        hv_Vx.Clear();
        hv_Vz.Clear();
        hv_Vx[0] = MatRot[0];
        hv_Vx[1] = MatRot[3];
        hv_Vx[2] = MatRot[6];
        hv_Vz[0] = MatRot[2];
        hv_Vz[1] = MatRot[5];
        hv_Vz[2] = MatRot[8];
        hv_Vector.Clear();
        hv_Vector[0] = NormalVec[0];
        hv_Vector[1] = NormalVec[1];
        hv_Vector[2] = NormalVec[2];
        //实际深度结果为
        TupleMult(hv_Vx, hv_D, &hv_DVx);
        TupleMult(hv_Vz, hv_Width, &hv_WVz);
        TupleAdd(hv_DVx, hv_WVz, &hv_Sum);

        TupleMult(hv_Vector, hv_Sum, &hv_VectorWidth);
        TupleMult(hv_VectorWidth, hv_VectorWidth, &hv_Prod);
        TupleSum(hv_Prod, &hv_Sum1);
        hv_Deepth = hv_Sum1.TupleSqrt();
        tmpDeep = hv_Deepth[0].D();
        deepth = tmpDeep;
    }
    void Distance_point_line_3d(HTuple hv_RightUpPoint, HTuple hv_RightLineVector, HTuple hv_LeftUpPoint1,
                                HTuple *hv_Distan1)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Diff, hv_MultLU, hv_NormS2, hv_LemDa;
        HTuple hv_Prod, hv_Sum, hv_Diff1, hv_Dis1, hv_Distance3D1;

        (*hv_Distan1) = HTuple();
        TupleSub(hv_LeftUpPoint1, hv_RightUpPoint, &hv_Diff);
        DotVector(hv_Diff, hv_RightLineVector, &hv_MultLU);
        Cal2Norm(hv_RightLineVector, &hv_NormS2);
        hv_LemDa = hv_MultLU / hv_NormS2;
        if (0 != (HTuple(int(hv_LemDa > -0.005)).TupleAnd(int(hv_LemDa <= 1))))
        {
            //*将LemDa系数代入
            TupleMult(hv_RightLineVector, hv_LemDa, &hv_Prod);
            TupleAdd(hv_RightUpPoint, hv_Prod, &hv_Sum);
            TupleSub(hv_LeftUpPoint1, hv_Sum, &hv_Diff1);
            //*
            Cal2Norm(hv_Diff1, &hv_Dis1);
            (*hv_Distan1) = hv_Dis1;
        }
        else
        {
            distance_3d_pp(hv_LeftUpPoint1, hv_RightUpPoint, &hv_Distance3D1);
            (*hv_Distan1) = hv_Distance3D1;
            // distance_3d_pp (LeftDownPoint1, RightUpPoint, Distance3D2)
            // Distan1 := min([Distance3D1, Distance3D2])
        }
        return;
    }

    void CalBoxLength(double Vector[3], double s2, double s1, double LeftUpPoint[3],
                      double LeftDownPoint[3], double RightUpPoint[3], double RightDownPoint[3], double &boxLength)
    {

        // Local iconic variables
        boxLength = 0;
        // Local control variables
        HTuple hv_Vector2, hv_LeftUpPoint1, hv_LeftDownPoint1;
        HTuple hv_LeftLineVector, hv_RightLineVector, hv_MultPointS;
        HTuple hv_Pow, hv_NormS1, hv_NormS2, hv_SubOrigin, hv_MultPointO1;
        HTuple hv_MultPointO2, hv_Coe, hv_LemDa1, hv_LemDa2, hv_Prod2;
        HTuple hv_LeftInterPoint, hv_Prod3, hv_RightInterPoint;
        HTuple hv_Distance3D, hv_Distan1, hv_Distan2, hv_Distan3;
        HTuple hv_Distan4;
        HTuple hv_Vector, hv_s2, hv_s1;
        HTuple hv_LeftUpPoint, hv_LeftDownPoint, hv_RightUpPoint, hv_RightDownPoint;
        HTuple hv_Distance;
        //--------------------输入参数先转换为HTuple类型
        hv_Vector.Clear();
        hv_s2.Clear();
        hv_s1.Clear();
        hv_LeftUpPoint.Clear();
        hv_LeftDownPoint.Clear();
        hv_RightUpPoint.Clear();
        hv_RightDownPoint.Clear();

        hv_Vector[0] = Vector[0];
        hv_Vector[1] = Vector[1];
        hv_Vector[2] = Vector[2];

        hv_s2 = HTuple(s2);
        hv_s1 = HTuple(s1);

        hv_LeftUpPoint[0] = LeftUpPoint[0];
        hv_LeftUpPoint[1] = LeftUpPoint[1];
        hv_LeftUpPoint[2] = LeftUpPoint[2];
        hv_LeftDownPoint[0] = LeftDownPoint[0];
        hv_LeftDownPoint[1] = LeftDownPoint[1];
        hv_LeftDownPoint[2] = LeftDownPoint[2];
        hv_RightUpPoint[0] = RightUpPoint[0];
        hv_RightUpPoint[1] = RightUpPoint[1];
        hv_RightUpPoint[2] = RightUpPoint[2];
        hv_RightDownPoint[0] = RightDownPoint[0];
        hv_RightDownPoint[1] = RightDownPoint[1];
        hv_RightDownPoint[2] = RightDownPoint[2];
        //----------------------------------------------------------------------------

        TupleMult(hv_Vector, hv_s2 - hv_s1, &hv_Vector2);
        //*计算移动后左侧的端点坐标P11,P21
        TupleAdd(hv_LeftUpPoint, hv_Vector2, &hv_LeftUpPoint1);
        TupleAdd(hv_LeftDownPoint, hv_Vector2, &hv_LeftDownPoint1);

        //*计算直线P11P21的向量
        TupleSub(hv_LeftUpPoint1, hv_LeftDownPoint1, &hv_LeftLineVector);
        //*计算直线P3P4的向量
        TupleSub(hv_RightUpPoint, hv_RightDownPoint, &hv_RightLineVector);

        //*计算向量方向的系数值
        //*计算S1*S2
        DotVector(hv_LeftLineVector, hv_RightLineVector, &hv_MultPointS);
        TuplePow(hv_MultPointS, 2, &hv_Pow);

        //*计算直线向量P11P21的2-范数
        Cal2Norm(hv_LeftLineVector, &hv_NormS1);

        //*计算直线向量P3P4的2-范数
        Cal2Norm(hv_RightLineVector, &hv_NormS2);
        //*计算向量的起始端点的
        TupleSub(hv_LeftUpPoint1, hv_RightUpPoint, &hv_SubOrigin);
        DotVector(hv_SubOrigin, hv_LeftLineVector, &hv_MultPointO1);
        DotVector(hv_SubOrigin, hv_RightLineVector, &hv_MultPointO2);
        hv_Coe = (hv_NormS1 * hv_NormS2) - hv_Pow;
        hv_LemDa1 = ((hv_MultPointS * hv_MultPointO2) - (hv_NormS2 * hv_MultPointO1)) / hv_Coe;

        hv_LemDa2 = ((hv_MultPointS * hv_MultPointO1) - (hv_NormS1 * hv_MultPointO2)) / hv_Coe;
        hv_Distance.Clear();
        if (0 != (HTuple(HTuple(HTuple(int(hv_LemDa1 > -0.1)).TupleAnd(int(hv_LemDa1 <= 1))).TupleAnd(int(hv_LemDa2 > -0.1))).TupleAnd(int(hv_LemDa2 <= 1))))
        {
            //*最短距离与左侧线的交点为
            TupleMult(hv_LeftLineVector, hv_LemDa1, &hv_Prod2);
            TupleAdd(hv_LeftUpPoint1, hv_Prod2, &hv_LeftInterPoint);
            //*最短距离与右侧线的交点为
            TupleMult(hv_RightLineVector, hv_LemDa2, &hv_Prod3);
            TupleAdd(hv_RightUpPoint, hv_Prod3, &hv_RightInterPoint);
            distance_3d_pp(hv_RightInterPoint, hv_LeftInterPoint, &hv_Distance3D);
            hv_Distance = hv_Distance3D;
        }
        else
        {
            //*计算左侧线的端点到右侧线段的距离LeftUpDis和LeftDownDis
            //*先计算左上点到右侧线段的距离（线向量：RightLineVector，线的起点：RightUpPoint;  点：LeftUpPoint1; 距离结果：Distan1）
            Distance_point_line_3d(hv_RightUpPoint, hv_RightLineVector, hv_LeftUpPoint1,
                                   &hv_Distan1);
            Distance_point_line_3d(hv_RightUpPoint, hv_RightLineVector, hv_LeftDownPoint1,
                                   &hv_Distan2);

            //*计算右侧线的端点到左侧线段的距离RightUpDis和RightDownDis
            Distance_point_line_3d(hv_LeftUpPoint1, hv_LeftLineVector, hv_RightUpPoint, &hv_Distan3);
            Distance_point_line_3d(hv_LeftUpPoint1, hv_LeftLineVector, hv_RightDownPoint,
                                   &hv_Distan4);
            hv_Distance = (((hv_Distan1.TupleConcat(hv_Distan2)).TupleConcat(hv_Distan3)).TupleConcat(hv_Distan4)).TupleMin();
        }
        boxLength = hv_Distance[0].D();
        return;
    }

    // Procedures
    void CalCenterLinePoints(HTuple hv_LeftUp, HTuple hv_LeftDown, HTuple hv_RightUp,
                             HTuple hv_RightDown, HTuple hv_MeasureWidth, HTuple *hv_Rows, HTuple *hv_Columns,
                             HTuple *hv_tuple_Phi, HTuple *hv_tuple_Len1, HTuple *hv_tuple_Len2)
    {

        // Local iconic variables
        HObject ho_Cross5, ho_Cross6, ho_RegionLines;

        // Local control variables
        HTuple hv_LeftCenterRow, hv_LeftCenterCol, hv_LengthL;
        HTuple hv_Phi1, hv_RightCenterRow, hv_RightCenterCol, hv_LengthR;
        HTuple hv_Phi2;

        //*根据四个端点坐标计算中心线对应的坐标
        LinePosition(HTuple(hv_LeftUp[0]), HTuple(hv_LeftUp[1]), HTuple(hv_LeftDown[0]),
                     HTuple(hv_LeftDown[1]), &hv_LeftCenterRow, &hv_LeftCenterCol, &hv_LengthL,
                     &hv_Phi1);
        GenCrossContourXld(&ho_Cross5, hv_LeftCenterRow, hv_LeftCenterCol, 6, hv_Phi1);
        LinePosition(HTuple(hv_RightUp[0]), HTuple(hv_RightUp[1]), HTuple(hv_RightDown[0]),
                     HTuple(hv_RightDown[1]), &hv_RightCenterRow, &hv_RightCenterCol, &hv_LengthR,
                     &hv_Phi2);
        GenCrossContourXld(&ho_Cross6, hv_RightCenterRow, hv_RightCenterCol, 6, hv_Phi2);
        GenRegionLine(&ho_RegionLines, hv_LeftCenterRow, hv_LeftCenterCol, hv_RightCenterRow,
                      hv_RightCenterCol);
        GetRegionPoints(ho_RegionLines, &(*hv_Rows), &(*hv_Columns));
        (*hv_tuple_Phi) = HTuple((*hv_Rows).TupleLength(), (hv_Phi1 + hv_Phi2) / 2);
        (*hv_tuple_Len1) = HTuple((*hv_Rows).TupleLength(), ((hv_LengthL + hv_LengthR) / 4) + 30);
        (*hv_tuple_Len2) = HTuple((*hv_Rows).TupleLength(), hv_MeasureWidth);

        return;
    }

    void CalcuCornerPoint(HObject ho_RegionFillUp, HObject ho_ImageReduced1, HObject ho_ImageReduced2,
                          HObject ho_ImageReduced3, HTuple hv_RightUp, HTuple *hv_LeftUpPoint)
    {

        // Local iconic variables
        HObject ho_RightUpCircle, ho_RegionIntersection;

        // Local control variables
        HTuple hv_Radius1, hv_MeanX, hv_Deviation, hv_MeanY;
        HTuple hv_Deviation1, hv_MeanZ, hv_Deviation2;

        hv_Radius1 = 5;
        GenCircle(&ho_RightUpCircle, HTuple(hv_RightUp[0]), HTuple(hv_RightUp[1]), hv_Radius1);
        //*计算坐标
        Intersection(ho_RightUpCircle, ho_RegionFillUp, &ho_RegionIntersection);
        Intensity(ho_RegionIntersection, ho_ImageReduced1, &hv_MeanX, &hv_Deviation);
        Intensity(ho_RegionIntersection, ho_ImageReduced2, &hv_MeanY, &hv_Deviation1);
        Intensity(ho_RegionIntersection, ho_ImageReduced3, &hv_MeanZ, &hv_Deviation2);
        while (0 != (int(hv_MeanZ == 0)))
        {
            hv_Radius1 += 3;
            GenCircle(&ho_RightUpCircle, HTuple(hv_RightUp[0]), HTuple(hv_RightUp[1]), hv_Radius1);
            Intersection(ho_RightUpCircle, ho_RegionFillUp, &ho_RegionIntersection);
            Intensity(ho_RegionIntersection, ho_ImageReduced1, &hv_MeanX, &hv_Deviation);
            Intensity(ho_RegionIntersection, ho_ImageReduced2, &hv_MeanY, &hv_Deviation1);
            Intensity(ho_RegionIntersection, ho_ImageReduced3, &hv_MeanZ, &hv_Deviation2);
        }
        // intensity (RegionFillUp, ImageReduced3, Mean, Deviation3)
        (*hv_LeftUpPoint).Clear();
        (*hv_LeftUpPoint).Append(hv_MeanX);
        (*hv_LeftUpPoint).Append(hv_MeanY);
        (*hv_LeftUpPoint).Append(hv_MeanZ);
        // CornerPose := [MeanX, MeanY, MeanZ, 0, 0, 0, 0]
        // gen_sphere_object_model_3d (CornerPose, 16, CornerPoint3D)
        return;
    }

    void CalMeanPoint(HTuple hv_MatW, HTuple hv_LineUpX, HTuple *hv_meanX)
    {

        // Local control variables
        HTuple hv_VectorID, hv_Newtuple, hv_ValueW, hv_WTrace;
        HTuple hv_Prod, hv_SumX;

        GetDiagonalMatrix(hv_MatW, 0, &hv_VectorID);
        TupleGenConst(hv_LineUpX.TupleLength(), 0, &hv_Newtuple);
        GetValueMatrix(hv_VectorID, HTuple::TupleGenSequence(0, (hv_LineUpX.TupleLength()) - 1, 1),
                       hv_Newtuple, &hv_ValueW);
        TupleSum(hv_ValueW, &hv_WTrace);
        TupleMult(hv_ValueW, hv_LineUpX, &hv_Prod);
        TupleSum(hv_Prod, &hv_SumX);
        TupleDiv(hv_SumX, hv_WTrace, &(*hv_meanX));
        return;
    }

    void CrossMultFunc(HTuple hv_N, HTuple hv_N1, HTuple *hv_VectorCross)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_VectorCrossX, hv_VectorCrossY, hv_VectorCrossZ;
        HTuple hv_a1, hv_a2, hv_a3, hv_b1, hv_b2, hv_b3;

        hv_a1 = ((const HTuple &)hv_N)[0];
        hv_a2 = ((const HTuple &)hv_N)[1];
        hv_a3 = ((const HTuple &)hv_N)[2];
        hv_b1 = ((const HTuple &)hv_N1)[0];
        hv_b2 = ((const HTuple &)hv_N1)[1];
        hv_b3 = ((const HTuple &)hv_N1)[2];
        hv_VectorCrossX = (hv_a2 * hv_b3) - (hv_b2 * hv_a3);
        hv_VectorCrossY = ((-hv_a1) * hv_b3) + (hv_b1 * hv_a3);
        hv_VectorCrossZ = (hv_a1 * hv_b2) - (hv_b1 * hv_a2);
        (*hv_VectorCross).Clear();
        (*hv_VectorCross).Append(hv_VectorCrossX);
        (*hv_VectorCross).Append(hv_VectorCrossY);
        (*hv_VectorCross).Append(hv_VectorCrossZ);
        return;
    }

    // Chapter: Graphics / Output
    // Short Description: Determine the optimum distance of the object to obtain a reasonable visualization
    void determine_optimum_pose_distance(HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
                                         HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Rows, hv_Cols, hv_MinMinZ, hv_BB, hv_Index;
        HTuple hv_CurrBB, hv_Exception, hv_Seq, hv_DXMax, hv_DYMax;
        HTuple hv_DZMax, hv_Diameter, hv_ZAdd, hv_BBX0, hv_BBX1;
        HTuple hv_BBY0, hv_BBY1, hv_BBZ0, hv_BBZ1, hv_X, hv_Y;
        HTuple hv_Z, hv_HomMat3DIn, hv_QX_In, hv_QY_In, hv_QZ_In;
        HTuple hv_PoseInter, hv_HomMat3D, hv_QX, hv_QY, hv_QZ;
        HTuple hv_Cx, hv_Cy, hv_DR, hv_DC, hv_MaxDist, hv_HomMat3DRotate;
        HTuple hv_ImageWidth, hv_ImageHeight, hv_MinImageSize;
        HTuple hv_Zs, hv_ZDiff, hv_ScaleZ, hv_ZNew;

        // Determine the optimum distance of the object to obtain
        // a reasonable visualization
        //
        hv_Rows = HTuple();
        hv_Cols = HTuple();
        hv_MinMinZ = 1e30;
        hv_BB = HTuple();
        {
            HTuple end_val7 = (hv_ObjectModel3DID.TupleLength()) - 1;
            HTuple step_val7 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val7, step_val7); hv_Index += step_val7)
            {
                try
                {
                    GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "bounding_box1",
                                           &hv_CurrBB);
                    hv_BB = hv_BB.TupleConcat(hv_CurrBB);
                }
                // catch (Exception)
                catch (HException &HDevExpDefaultException)
                {
                    HDevExpDefaultException.ToHTuple(&hv_Exception);
                    // 3D object model is empty / has no bounding box -> ignore it
                }
            }
        }
        if (0 != (int((((hv_BB.TupleAbs()).TupleConcat(0)).TupleSum()) == 0.0)))
        {
            hv_BB.Clear();
            hv_BB.Append(-(HTuple(HTuple::TupleRand(3) * 1e-20).TupleAbs()));
            hv_BB.Append(HTuple(HTuple::TupleRand(3) * 1e-20).TupleAbs());
        }
        // Calculate diameter over all objects to be visualized
        hv_Seq = HTuple::TupleGenSequence(0, (hv_BB.TupleLength()) - 1, 6);
        hv_DXMax = (HTuple(hv_BB[hv_Seq + 3]).TupleMax()) - (HTuple(hv_BB[hv_Seq]).TupleMin());
        hv_DYMax = (HTuple(hv_BB[hv_Seq + 4]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 1]).TupleMin());
        hv_DZMax = (HTuple(hv_BB[hv_Seq + 5]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 2]).TupleMin());
        hv_Diameter = (((hv_DXMax * hv_DXMax) + (hv_DYMax * hv_DYMax)) + (hv_DZMax * hv_DZMax)).TupleSqrt();
        // Allow the visualization of single points or extremely small objects
        hv_ZAdd = 0.0;
        if (0 != (int((hv_Diameter.TupleMax()) < 1e-10)))
        {
            hv_ZAdd = 0.01;
        }
        // Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
        // to projection errors
        if (0 != (int((hv_Diameter.TupleMin()) < 1e-10)))
        {
            hv_Diameter = hv_Diameter - (((((hv_Diameter - 1e-10).TupleSgn()) - 1).TupleSgn()) * 1e-10);
        }
        // Move all points infront of the camera
        hv_BBX0 = HTuple(hv_BB[hv_Seq + 0]);
        hv_BBX1 = HTuple(hv_BB[hv_Seq + 3]);
        hv_BBY0 = HTuple(hv_BB[hv_Seq + 1]);
        hv_BBY1 = HTuple(hv_BB[hv_Seq + 4]);
        hv_BBZ0 = HTuple(hv_BB[hv_Seq + 2]);
        hv_BBZ1 = HTuple(hv_BB[hv_Seq + 5]);
        hv_X.Clear();
        hv_X.Append(hv_BBX0);
        hv_X.Append(hv_BBX0);
        hv_X.Append(hv_BBX0);
        hv_X.Append(hv_BBX0);
        hv_X.Append(hv_BBX1);
        hv_X.Append(hv_BBX1);
        hv_X.Append(hv_BBX1);
        hv_X.Append(hv_BBX1);
        hv_Y.Clear();
        hv_Y.Append(hv_BBY0);
        hv_Y.Append(hv_BBY0);
        hv_Y.Append(hv_BBY1);
        hv_Y.Append(hv_BBY1);
        hv_Y.Append(hv_BBY0);
        hv_Y.Append(hv_BBY0);
        hv_Y.Append(hv_BBY1);
        hv_Y.Append(hv_BBY1);
        hv_Z.Clear();
        hv_Z.Append(hv_BBZ0);
        hv_Z.Append(hv_BBZ1);
        hv_Z.Append(hv_BBZ0);
        hv_Z.Append(hv_BBZ1);
        hv_Z.Append(hv_BBZ0);
        hv_Z.Append(hv_BBZ1);
        hv_Z.Append(hv_BBZ0);
        hv_Z.Append(hv_BBZ1);
        PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
        AffineTransPoint3d(hv_HomMat3DIn, hv_X, hv_Y, hv_Z, &hv_QX_In, &hv_QY_In, &hv_QZ_In);
        PoseCompose(((HTuple(0).Append(0)).TupleConcat((-(hv_QZ_In.TupleMin())) + (2 * (hv_Diameter.TupleMax())))).TupleConcat((((HTuple(0).Append(0)).Append(0)).Append(0))),
                    hv_PoseIn, &hv_PoseInter);
        PoseToHomMat3d(hv_PoseInter, &hv_HomMat3D);
        // Determine the maximum extension of the projection
        AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
        Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
        hv_MinMinZ = hv_QZ.TupleMin();
        get_cam_par_data(hv_CamParam, "cx", &hv_Cx);
        get_cam_par_data(hv_CamParam, "cy", &hv_Cy);
        hv_DR = hv_Rows - hv_Cy;
        hv_DC = hv_Cols - hv_Cx;
        hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
        hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
        hv_MaxDist = ((hv_DR * hv_DR) + (hv_DC * hv_DC)).TupleSqrt();
        //
        if (0 != (int(hv_MaxDist < 1e-10)))
        {
            // If the object has no extension in the above projection (looking along
            // a line), we determine the extension of the object in a rotated view
            HomMat3dRotateLocal(hv_HomMat3D, HTuple(90).TupleRad(), "x", &hv_HomMat3DRotate);
            AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
            Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
            hv_DR = hv_Rows - hv_Cy;
            hv_DC = hv_Cols - hv_Cx;
            hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
            hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
            hv_MaxDist = (hv_MaxDist.TupleConcat(((hv_DR * hv_DR) + (hv_DC * hv_DC)).TupleSqrt())).TupleMax();
        }
        //
        get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
        get_cam_par_data(hv_CamParam, "image_height", &hv_ImageHeight);
        hv_MinImageSize = (hv_ImageWidth.TupleConcat(hv_ImageHeight)).TupleMin();
        //
        hv_Z = ((const HTuple &)hv_PoseInter)[2];
        hv_Zs = hv_MinMinZ;
        hv_ZDiff = hv_Z - hv_Zs;
        hv_ScaleZ = hv_MaxDist / (((0.5 * hv_MinImageSize) * hv_ImageCoverage) * 2.0);
        hv_ZNew = ((hv_ScaleZ * hv_Zs) + hv_ZDiff) + hv_ZAdd;
        (*hv_PoseOut) = hv_PoseInter.TupleReplace(2, hv_ZNew);
        //
        return;
    }

    void distance_3d_pp(HTuple hv_point1, HTuple hv_point2, HTuple *hv_Distance3DPP)
    {

        // Local iconic variables

        (*hv_Distance3DPP) = ((((HTuple(hv_point1[0]) - HTuple(hv_point2[0])) * (HTuple(hv_point1[0]) - HTuple(hv_point2[0]))) + ((HTuple(hv_point1[1]) - HTuple(hv_point2[1])) * (HTuple(hv_point1[1]) - HTuple(hv_point2[1])))) + ((HTuple(hv_point1[2]) - HTuple(hv_point2[2])) * (HTuple(hv_point1[2]) - HTuple(hv_point2[2])))).TupleSqrt();
        return;
    }

    void DotVector(HTuple hv_lineVecUp, HTuple hv_lineVecRight, HTuple *hv_DotA)
    {

        // Local control variables
        HTuple hv_Prod;

        TupleMult(hv_lineVecUp, hv_lineVecRight, &hv_Prod);
        TupleSum(hv_Prod, &(*hv_DotA));
        return;
    }

    void FitLine3D(HTuple hv_LineUpX, HTuple hv_LineUpY, HTuple hv_LineUpZ, HTuple *hv_MeanPoint1,
                   HTuple *hv_lineVec1)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_MatA, hv_Newtuple, hv_Newtuple1, hv_Newtuple2;
        HTuple hv_Tol, hv_MatW, hv_MeanPoint, hv_lineVec, hv_N;
        HTuple hv_Vector1, hv_Prod, hv_Sum, hv_Norm;

        //*Set Matrix
        CreateMatrix(hv_LineUpX.TupleLength(), 3, 0, &hv_MatA);
        TupleGenConst(hv_LineUpX.TupleLength(), 0, &hv_Newtuple);
        SetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, (hv_LineUpX.TupleLength()) - 1, 1),
                       hv_Newtuple, hv_LineUpX);
        TupleGenConst(hv_LineUpX.TupleLength(), 1, &hv_Newtuple1);
        SetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, (hv_LineUpX.TupleLength()) - 1, 1),
                       hv_Newtuple1, hv_LineUpY);
        TupleGenConst(hv_LineUpX.TupleLength(), 2, &hv_Newtuple2);
        SetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, (hv_LineUpX.TupleLength()) - 1, 1),
                       hv_Newtuple2, hv_LineUpZ);

        hv_Tol = 1e-2;
        CreateMatrix(hv_LineUpX.TupleLength(), hv_LineUpX.TupleLength(), "identity", &hv_MatW);

        fitLine_wls(hv_MatA, hv_MatW, &hv_MeanPoint, &hv_lineVec);

        getWLSWeight(hv_MatA, hv_MeanPoint, hv_lineVec, &hv_MatW);
        hv_N = 1;
        while (0 != (int(hv_N < 5)))
        {
            hv_N += 1;
            fitLine_wls(hv_MatA, hv_MatW, &(*hv_MeanPoint1), &(*hv_lineVec1));
            CrossMultFunc((*hv_lineVec1), hv_lineVec, &hv_Vector1);
            TupleMult(hv_Vector1, hv_Vector1, &hv_Prod);
            TupleSum(hv_Prod, &hv_Sum);
            hv_Norm = hv_Sum.TupleSqrt();
            if (0 != (int(hv_Tol > hv_Norm)))
            {
                break;
            }
            getWLSWeight(hv_MatA, (*hv_MeanPoint1), (*hv_lineVec1), &hv_MatW);
            hv_lineVec = (*hv_lineVec1);
        }
        return;
    }

    void fitLine_wls(HTuple hv_MatA, HTuple hv_MatW, HTuple *hv_MeanPoint, HTuple *hv_lineVec)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Rows2, hv_Columns2, hv_MatA0, hv_Zero;
        HTuple hv_Ones, hv_Twos, hv_LineUpX, hv_LineUpY, hv_LineUpZ;
        HTuple hv_meanX, hv_meanY, hv_meanZ, hv_I, hv_Value, hv_Diff;
        HTuple hv_MatrixMultID, hv_MatA1, hv_EigenvaluesID, hv_EigenvectorsID;
        HTuple hv_Value1, hv_Value2, hv_Diff1, hv_Prod, hv_Sum;

        GetSizeMatrix(hv_MatA, &hv_Rows2, &hv_Columns2);
        CreateMatrix(hv_Rows2, hv_Columns2, 0, &hv_MatA0);
        TupleGenConst(hv_Rows2, 0, &hv_Zero);
        TupleGenConst(hv_Rows2, 1, &hv_Ones);
        TupleGenConst(hv_Rows2, 2, &hv_Twos);

        GetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, hv_Rows2 - 1, 1), hv_Zero, &hv_LineUpX);
        GetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, hv_Rows2 - 1, 1), hv_Ones, &hv_LineUpY);
        GetValueMatrix(hv_MatA, HTuple::TupleGenSequence(0, hv_Rows2 - 1, 1), hv_Twos, &hv_LineUpZ);

        CalMeanPoint(hv_MatW, hv_LineUpX, &hv_meanX);
        CalMeanPoint(hv_MatW, hv_LineUpY, &hv_meanY);
        CalMeanPoint(hv_MatW, hv_LineUpZ, &hv_meanZ);
        (*hv_MeanPoint).Clear();
        (*hv_MeanPoint).Append(hv_meanX);
        (*hv_MeanPoint).Append(hv_meanY);
        (*hv_MeanPoint).Append(hv_meanZ);
        {
            HTuple end_val14 = hv_Rows2 - 1;
            HTuple step_val14 = 1;
            for (hv_I = 0; hv_I.Continue(end_val14, step_val14); hv_I += step_val14)
            {
                GetValueMatrix(hv_MatA, (hv_I.TupleConcat(hv_I)).TupleConcat(hv_I), ((HTuple(0).Append(1)).Append(2)),
                               &hv_Value);
                TupleSub(hv_Value, (*hv_MeanPoint), &hv_Diff);

                SetValueMatrix(hv_MatA0, (hv_I.TupleConcat(hv_I)).TupleConcat(hv_I), ((HTuple(0).Append(1)).Append(2)),
                               hv_Diff);
            }
        }

        MultMatrix(hv_MatA0, hv_MatW, "ATB", &hv_MatrixMultID);
        MultMatrix(hv_MatrixMultID, hv_MatA0, "AB", &hv_MatA1);
        EigenvaluesSymmetricMatrix(hv_MatA1, "true", &hv_EigenvaluesID, &hv_EigenvectorsID);

        GetValueMatrix(hv_EigenvectorsID, ((HTuple(0).Append(1)).Append(2)), ((HTuple(2).Append(2)).Append(2)),
                       &(*hv_lineVec));
        GetValueMatrix(hv_MatA, ((hv_Rows2 - 1).TupleConcat(hv_Rows2 - 1)).TupleConcat(hv_Rows2 - 1),
                       ((HTuple(0).Append(1)).Append(2)), &hv_Value1);
        GetValueMatrix(hv_MatA, ((HTuple(0).Append(0)).Append(0)), ((HTuple(0).Append(1)).Append(2)),
                       &hv_Value2);
        TupleSub(hv_Value1, hv_Value2, &hv_Diff1);
        TupleMult(hv_Diff1, (*hv_lineVec), &hv_Prod);
        TupleSum(hv_Prod, &hv_Sum);
        if (0 != (int(hv_Sum > 0)))
        {
            (*hv_lineVec) = -(*hv_lineVec);
        }
        return;
    }

    // Chapter: Calibration / Camera Parameters
    // Short Description: Get the value of a specified camera parameter from the camera parameter tuple.
    void get_cam_par_data(HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_CameraType, hv_CameraParamNames, hv_Index;
        HTuple hv_ParamNameInd, hv_I;

        // get_cam_par_data returns in ParamValue the value of the
        // parameter that is given in ParamName from the tuple of
        // camera parameters that is given in CameraParam.
        //
        // Get the parameter names that correspond to the
        // elements in the input camera parameter tuple.
        get_cam_par_names(hv_CameraParam, &hv_CameraType, &hv_CameraParamNames);
        //
        // Find the index of the requested camera data and return
        // the corresponding value.
        (*hv_ParamValue) = HTuple();
        {
            HTuple end_val11 = (hv_ParamName.TupleLength()) - 1;
            HTuple step_val11 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val11, step_val11); hv_Index += step_val11)
            {
                hv_ParamNameInd = HTuple(hv_ParamName[hv_Index]);
                if (0 != (int(hv_ParamNameInd == HTuple("camera_type"))))
                {
                    (*hv_ParamValue) = (*hv_ParamValue).TupleConcat(hv_CameraType);
                    continue;
                }
                hv_I = hv_CameraParamNames.TupleFind(hv_ParamNameInd);
                if (0 != (int(hv_I != -1)))
                {
                    (*hv_ParamValue) = (*hv_ParamValue).TupleConcat(HTuple(hv_CameraParam[hv_I]));
                }
                else
                {
                    throw HException("Unknown camera parameter " + hv_ParamNameInd);
                }
            }
        }
        return;
    }

    // Chapter: Calibration / Camera Parameters
    // Short Description: Get the names of the parameters in a camera parameter tuple.
    void get_cam_par_names(HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_CameraParamAreaScanDivision, hv_CameraParamAreaScanPolynomial;
        HTuple hv_CameraParamAreaScanTelecentricDivision, hv_CameraParamAreaScanTelecentricPolynomial;
        HTuple hv_CameraParamAreaScanTiltDivision, hv_CameraParamAreaScanTiltPolynomial;
        HTuple hv_CameraParamAreaScanImageSideTelecentricTiltDivision;
        HTuple hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial;
        HTuple hv_CameraParamAreaScanBilateralTelecentricTiltDivision;
        HTuple hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial;
        HTuple hv_CameraParamAreaScanObjectSideTelecentricTiltDivision;
        HTuple hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial;
        HTuple hv_CameraParamAreaScanHypercentricDivision, hv_CameraParamAreaScanHypercentricPolynomial;
        HTuple hv_CameraParamLinesScanDivision, hv_CameraParamLinesScanPolynomial;
        HTuple hv_CameraParamLinesScanTelecentricDivision, hv_CameraParamLinesScanTelecentricPolynomial;
        HTuple hv_CameraParamAreaScanTiltDivisionLegacy, hv_CameraParamAreaScanTiltPolynomialLegacy;
        HTuple hv_CameraParamAreaScanTelecentricDivisionLegacy;
        HTuple hv_CameraParamAreaScanTelecentricPolynomialLegacy;
        HTuple hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
        HTuple hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;

        // get_cam_par_names returns for each element in the camera
        // parameter tuple that is passed in CameraParam the name
        // of the respective camera parameter. The parameter names
        // are returned in ParamNames. Additionally, the camera
        // type is returned in CameraType. Alternatively, instead of
        // the camera parameters, the camera type can be passed in
        // CameraParam in form of one of the following strings:
        //   - 'area_scan_division'
        //   - 'area_scan_polynomial'
        //   - 'area_scan_tilt_division'
        //   - 'area_scan_tilt_polynomial'
        //   - 'area_scan_telecentric_division'
        //   - 'area_scan_telecentric_polynomial'
        //   - 'area_scan_tilt_bilateral_telecentric_division'
        //   - 'area_scan_tilt_bilateral_telecentric_polynomial'
        //   - 'area_scan_tilt_object_side_telecentric_division'
        //   - 'area_scan_tilt_object_side_telecentric_polynomial'
        //   - 'area_scan_hypercentric_division'
        //   - 'area_scan_hypercentric_polynomial'
        //   - 'line_scan_division'
        //   - 'line_scan_polynomial'
        //   - 'line_scan_telecentric_division'
        //   - 'line_scan_telecentric_polynomial'
        //
        hv_CameraParamAreaScanDivision.Clear();
        hv_CameraParamAreaScanDivision[0] = "focus";
        hv_CameraParamAreaScanDivision[1] = "kappa";
        hv_CameraParamAreaScanDivision[2] = "sx";
        hv_CameraParamAreaScanDivision[3] = "sy";
        hv_CameraParamAreaScanDivision[4] = "cx";
        hv_CameraParamAreaScanDivision[5] = "cy";
        hv_CameraParamAreaScanDivision[6] = "image_width";
        hv_CameraParamAreaScanDivision[7] = "image_height";
        hv_CameraParamAreaScanPolynomial.Clear();
        hv_CameraParamAreaScanPolynomial[0] = "focus";
        hv_CameraParamAreaScanPolynomial[1] = "k1";
        hv_CameraParamAreaScanPolynomial[2] = "k2";
        hv_CameraParamAreaScanPolynomial[3] = "k3";
        hv_CameraParamAreaScanPolynomial[4] = "p1";
        hv_CameraParamAreaScanPolynomial[5] = "p2";
        hv_CameraParamAreaScanPolynomial[6] = "sx";
        hv_CameraParamAreaScanPolynomial[7] = "sy";
        hv_CameraParamAreaScanPolynomial[8] = "cx";
        hv_CameraParamAreaScanPolynomial[9] = "cy";
        hv_CameraParamAreaScanPolynomial[10] = "image_width";
        hv_CameraParamAreaScanPolynomial[11] = "image_height";
        hv_CameraParamAreaScanTelecentricDivision.Clear();
        hv_CameraParamAreaScanTelecentricDivision[0] = "magnification";
        hv_CameraParamAreaScanTelecentricDivision[1] = "kappa";
        hv_CameraParamAreaScanTelecentricDivision[2] = "sx";
        hv_CameraParamAreaScanTelecentricDivision[3] = "sy";
        hv_CameraParamAreaScanTelecentricDivision[4] = "cx";
        hv_CameraParamAreaScanTelecentricDivision[5] = "cy";
        hv_CameraParamAreaScanTelecentricDivision[6] = "image_width";
        hv_CameraParamAreaScanTelecentricDivision[7] = "image_height";
        hv_CameraParamAreaScanTelecentricPolynomial.Clear();
        hv_CameraParamAreaScanTelecentricPolynomial[0] = "magnification";
        hv_CameraParamAreaScanTelecentricPolynomial[1] = "k1";
        hv_CameraParamAreaScanTelecentricPolynomial[2] = "k2";
        hv_CameraParamAreaScanTelecentricPolynomial[3] = "k3";
        hv_CameraParamAreaScanTelecentricPolynomial[4] = "p1";
        hv_CameraParamAreaScanTelecentricPolynomial[5] = "p2";
        hv_CameraParamAreaScanTelecentricPolynomial[6] = "sx";
        hv_CameraParamAreaScanTelecentricPolynomial[7] = "sy";
        hv_CameraParamAreaScanTelecentricPolynomial[8] = "cx";
        hv_CameraParamAreaScanTelecentricPolynomial[9] = "cy";
        hv_CameraParamAreaScanTelecentricPolynomial[10] = "image_width";
        hv_CameraParamAreaScanTelecentricPolynomial[11] = "image_height";
        hv_CameraParamAreaScanTiltDivision.Clear();
        hv_CameraParamAreaScanTiltDivision[0] = "focus";
        hv_CameraParamAreaScanTiltDivision[1] = "kappa";
        hv_CameraParamAreaScanTiltDivision[2] = "image_plane_dist";
        hv_CameraParamAreaScanTiltDivision[3] = "tilt";
        hv_CameraParamAreaScanTiltDivision[4] = "rot";
        hv_CameraParamAreaScanTiltDivision[5] = "sx";
        hv_CameraParamAreaScanTiltDivision[6] = "sy";
        hv_CameraParamAreaScanTiltDivision[7] = "cx";
        hv_CameraParamAreaScanTiltDivision[8] = "cy";
        hv_CameraParamAreaScanTiltDivision[9] = "image_width";
        hv_CameraParamAreaScanTiltDivision[10] = "image_height";
        hv_CameraParamAreaScanTiltPolynomial.Clear();
        hv_CameraParamAreaScanTiltPolynomial[0] = "focus";
        hv_CameraParamAreaScanTiltPolynomial[1] = "k1";
        hv_CameraParamAreaScanTiltPolynomial[2] = "k2";
        hv_CameraParamAreaScanTiltPolynomial[3] = "k3";
        hv_CameraParamAreaScanTiltPolynomial[4] = "p1";
        hv_CameraParamAreaScanTiltPolynomial[5] = "p2";
        hv_CameraParamAreaScanTiltPolynomial[6] = "image_plane_dist";
        hv_CameraParamAreaScanTiltPolynomial[7] = "tilt";
        hv_CameraParamAreaScanTiltPolynomial[8] = "rot";
        hv_CameraParamAreaScanTiltPolynomial[9] = "sx";
        hv_CameraParamAreaScanTiltPolynomial[10] = "sy";
        hv_CameraParamAreaScanTiltPolynomial[11] = "cx";
        hv_CameraParamAreaScanTiltPolynomial[12] = "cy";
        hv_CameraParamAreaScanTiltPolynomial[13] = "image_width";
        hv_CameraParamAreaScanTiltPolynomial[14] = "image_height";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Clear();
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[0] = "focus";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[1] = "kappa";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[2] = "tilt";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[3] = "rot";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[4] = "sx";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[5] = "sy";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[6] = "cx";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[7] = "cy";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[8] = "image_width";
        hv_CameraParamAreaScanImageSideTelecentricTiltDivision[9] = "image_height";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Clear();
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[0] = "focus";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[1] = "k1";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[2] = "k2";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[3] = "k3";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[4] = "p1";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[5] = "p2";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[6] = "tilt";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[7] = "rot";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[8] = "sx";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[9] = "sy";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[10] = "cx";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[11] = "cy";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[12] = "image_width";
        hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[13] = "image_height";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Clear();
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[0] = "magnification";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[1] = "kappa";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[2] = "tilt";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[3] = "rot";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[4] = "sx";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[5] = "sy";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[6] = "cx";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[7] = "cy";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[8] = "image_width";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivision[9] = "image_height";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Clear();
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[0] = "magnification";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[1] = "k1";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[2] = "k2";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[3] = "k3";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[4] = "p1";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[5] = "p2";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[6] = "tilt";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[7] = "rot";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[8] = "sx";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[9] = "sy";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[10] = "cx";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[11] = "cy";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[12] = "image_width";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[13] = "image_height";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Clear();
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[0] = "magnification";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[1] = "kappa";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[2] = "image_plane_dist";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[3] = "tilt";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[4] = "rot";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[5] = "sx";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[6] = "sy";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[7] = "cx";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[8] = "cy";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[9] = "image_width";
        hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[10] = "image_height";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Clear();
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[0] = "magnification";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[1] = "k1";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[2] = "k2";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[3] = "k3";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[4] = "p1";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[5] = "p2";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[6] = "image_plane_dist";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[7] = "tilt";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[8] = "rot";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[9] = "sx";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[10] = "sy";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[11] = "cx";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[12] = "cy";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[13] = "image_width";
        hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[14] = "image_height";
        hv_CameraParamAreaScanHypercentricDivision.Clear();
        hv_CameraParamAreaScanHypercentricDivision[0] = "focus";
        hv_CameraParamAreaScanHypercentricDivision[1] = "kappa";
        hv_CameraParamAreaScanHypercentricDivision[2] = "sx";
        hv_CameraParamAreaScanHypercentricDivision[3] = "sy";
        hv_CameraParamAreaScanHypercentricDivision[4] = "cx";
        hv_CameraParamAreaScanHypercentricDivision[5] = "cy";
        hv_CameraParamAreaScanHypercentricDivision[6] = "image_width";
        hv_CameraParamAreaScanHypercentricDivision[7] = "image_height";
        hv_CameraParamAreaScanHypercentricPolynomial.Clear();
        hv_CameraParamAreaScanHypercentricPolynomial[0] = "focus";
        hv_CameraParamAreaScanHypercentricPolynomial[1] = "k1";
        hv_CameraParamAreaScanHypercentricPolynomial[2] = "k2";
        hv_CameraParamAreaScanHypercentricPolynomial[3] = "k3";
        hv_CameraParamAreaScanHypercentricPolynomial[4] = "p1";
        hv_CameraParamAreaScanHypercentricPolynomial[5] = "p2";
        hv_CameraParamAreaScanHypercentricPolynomial[6] = "sx";
        hv_CameraParamAreaScanHypercentricPolynomial[7] = "sy";
        hv_CameraParamAreaScanHypercentricPolynomial[8] = "cx";
        hv_CameraParamAreaScanHypercentricPolynomial[9] = "cy";
        hv_CameraParamAreaScanHypercentricPolynomial[10] = "image_width";
        hv_CameraParamAreaScanHypercentricPolynomial[11] = "image_height";
        hv_CameraParamLinesScanDivision.Clear();
        hv_CameraParamLinesScanDivision[0] = "focus";
        hv_CameraParamLinesScanDivision[1] = "kappa";
        hv_CameraParamLinesScanDivision[2] = "sx";
        hv_CameraParamLinesScanDivision[3] = "sy";
        hv_CameraParamLinesScanDivision[4] = "cx";
        hv_CameraParamLinesScanDivision[5] = "cy";
        hv_CameraParamLinesScanDivision[6] = "image_width";
        hv_CameraParamLinesScanDivision[7] = "image_height";
        hv_CameraParamLinesScanDivision[8] = "vx";
        hv_CameraParamLinesScanDivision[9] = "vy";
        hv_CameraParamLinesScanDivision[10] = "vz";
        hv_CameraParamLinesScanPolynomial.Clear();
        hv_CameraParamLinesScanPolynomial[0] = "focus";
        hv_CameraParamLinesScanPolynomial[1] = "k1";
        hv_CameraParamLinesScanPolynomial[2] = "k2";
        hv_CameraParamLinesScanPolynomial[3] = "k3";
        hv_CameraParamLinesScanPolynomial[4] = "p1";
        hv_CameraParamLinesScanPolynomial[5] = "p2";
        hv_CameraParamLinesScanPolynomial[6] = "sx";
        hv_CameraParamLinesScanPolynomial[7] = "sy";
        hv_CameraParamLinesScanPolynomial[8] = "cx";
        hv_CameraParamLinesScanPolynomial[9] = "cy";
        hv_CameraParamLinesScanPolynomial[10] = "image_width";
        hv_CameraParamLinesScanPolynomial[11] = "image_height";
        hv_CameraParamLinesScanPolynomial[12] = "vx";
        hv_CameraParamLinesScanPolynomial[13] = "vy";
        hv_CameraParamLinesScanPolynomial[14] = "vz";
        hv_CameraParamLinesScanTelecentricDivision.Clear();
        hv_CameraParamLinesScanTelecentricDivision[0] = "magnification";
        hv_CameraParamLinesScanTelecentricDivision[1] = "kappa";
        hv_CameraParamLinesScanTelecentricDivision[2] = "sx";
        hv_CameraParamLinesScanTelecentricDivision[3] = "sy";
        hv_CameraParamLinesScanTelecentricDivision[4] = "cx";
        hv_CameraParamLinesScanTelecentricDivision[5] = "cy";
        hv_CameraParamLinesScanTelecentricDivision[6] = "image_width";
        hv_CameraParamLinesScanTelecentricDivision[7] = "image_height";
        hv_CameraParamLinesScanTelecentricDivision[8] = "vx";
        hv_CameraParamLinesScanTelecentricDivision[9] = "vy";
        hv_CameraParamLinesScanTelecentricDivision[10] = "vz";
        hv_CameraParamLinesScanTelecentricPolynomial.Clear();
        hv_CameraParamLinesScanTelecentricPolynomial[0] = "magnification";
        hv_CameraParamLinesScanTelecentricPolynomial[1] = "k1";
        hv_CameraParamLinesScanTelecentricPolynomial[2] = "k2";
        hv_CameraParamLinesScanTelecentricPolynomial[3] = "k3";
        hv_CameraParamLinesScanTelecentricPolynomial[4] = "p1";
        hv_CameraParamLinesScanTelecentricPolynomial[5] = "p2";
        hv_CameraParamLinesScanTelecentricPolynomial[6] = "sx";
        hv_CameraParamLinesScanTelecentricPolynomial[7] = "sy";
        hv_CameraParamLinesScanTelecentricPolynomial[8] = "cx";
        hv_CameraParamLinesScanTelecentricPolynomial[9] = "cy";
        hv_CameraParamLinesScanTelecentricPolynomial[10] = "image_width";
        hv_CameraParamLinesScanTelecentricPolynomial[11] = "image_height";
        hv_CameraParamLinesScanTelecentricPolynomial[12] = "vx";
        hv_CameraParamLinesScanTelecentricPolynomial[13] = "vy";
        hv_CameraParamLinesScanTelecentricPolynomial[14] = "vz";
        // Legacy parameter names
        hv_CameraParamAreaScanTiltDivisionLegacy.Clear();
        hv_CameraParamAreaScanTiltDivisionLegacy[0] = "focus";
        hv_CameraParamAreaScanTiltDivisionLegacy[1] = "kappa";
        hv_CameraParamAreaScanTiltDivisionLegacy[2] = "tilt";
        hv_CameraParamAreaScanTiltDivisionLegacy[3] = "rot";
        hv_CameraParamAreaScanTiltDivisionLegacy[4] = "sx";
        hv_CameraParamAreaScanTiltDivisionLegacy[5] = "sy";
        hv_CameraParamAreaScanTiltDivisionLegacy[6] = "cx";
        hv_CameraParamAreaScanTiltDivisionLegacy[7] = "cy";
        hv_CameraParamAreaScanTiltDivisionLegacy[8] = "image_width";
        hv_CameraParamAreaScanTiltDivisionLegacy[9] = "image_height";
        hv_CameraParamAreaScanTiltPolynomialLegacy.Clear();
        hv_CameraParamAreaScanTiltPolynomialLegacy[0] = "focus";
        hv_CameraParamAreaScanTiltPolynomialLegacy[1] = "k1";
        hv_CameraParamAreaScanTiltPolynomialLegacy[2] = "k2";
        hv_CameraParamAreaScanTiltPolynomialLegacy[3] = "k3";
        hv_CameraParamAreaScanTiltPolynomialLegacy[4] = "p1";
        hv_CameraParamAreaScanTiltPolynomialLegacy[5] = "p2";
        hv_CameraParamAreaScanTiltPolynomialLegacy[6] = "tilt";
        hv_CameraParamAreaScanTiltPolynomialLegacy[7] = "rot";
        hv_CameraParamAreaScanTiltPolynomialLegacy[8] = "sx";
        hv_CameraParamAreaScanTiltPolynomialLegacy[9] = "sy";
        hv_CameraParamAreaScanTiltPolynomialLegacy[10] = "cx";
        hv_CameraParamAreaScanTiltPolynomialLegacy[11] = "cy";
        hv_CameraParamAreaScanTiltPolynomialLegacy[12] = "image_width";
        hv_CameraParamAreaScanTiltPolynomialLegacy[13] = "image_height";
        hv_CameraParamAreaScanTelecentricDivisionLegacy.Clear();
        hv_CameraParamAreaScanTelecentricDivisionLegacy[0] = "focus";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[1] = "kappa";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[2] = "sx";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[3] = "sy";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[4] = "cx";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[5] = "cy";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[6] = "image_width";
        hv_CameraParamAreaScanTelecentricDivisionLegacy[7] = "image_height";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy.Clear();
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[0] = "focus";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[1] = "k1";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[2] = "k2";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[3] = "k3";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[4] = "p1";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[5] = "p2";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[6] = "sx";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[7] = "sy";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[8] = "cx";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[9] = "cy";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[10] = "image_width";
        hv_CameraParamAreaScanTelecentricPolynomialLegacy[11] = "image_height";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Clear();
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[0] = "focus";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[1] = "kappa";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[2] = "tilt";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[3] = "rot";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[4] = "sx";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[5] = "sy";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[6] = "cx";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[7] = "cy";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[8] = "image_width";
        hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[9] = "image_height";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Clear();
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[0] = "focus";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[1] = "k1";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[2] = "k2";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[3] = "k3";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[4] = "p1";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[5] = "p2";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[6] = "tilt";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[7] = "rot";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[8] = "sx";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[9] = "sy";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[10] = "cx";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[11] = "cy";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[12] = "image_width";
        hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[13] = "image_height";
        //
        // If the camera type is passed in CameraParam
        if (0 != (HTuple(int((hv_CameraParam.TupleLength()) == 1)).TupleAnd(HTuple(hv_CameraParam[0]).TupleIsString())))
        {
            (*hv_CameraType) = ((const HTuple &)hv_CameraParam)[0];
            if (0 != (int((*hv_CameraType) == HTuple("area_scan_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_telecentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_telecentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_hypercentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_hypercentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricPolynomial);
            }
            else if (0 != (HTuple(int((*hv_CameraType) == HTuple("line_scan_division"))).TupleOr(int((*hv_CameraType) == HTuple("line_scan")))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_telecentric_division"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanTelecentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_telecentric_polynomial"))))
            {
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanTelecentricPolynomial);
            }
            else
            {
                throw HException(("Unknown camera type '" + (*hv_CameraType)) + "' passed in CameraParam.");
            }
            return;
        }
        //
        // If the camera parameters are passed in CameraParam
        if (0 != ((HTuple(hv_CameraParam[0]).TupleIsString()).TupleNot()))
        {
            // Format of camera parameters for HALCON 12 and earlier
            switch ((hv_CameraParam.TupleLength()).I())
            {
                //
                // Area Scan
            case 8:
                // CameraType: 'area_scan_division' or 'area_scan_telecentric_division'
                if (0 != (int(HTuple(hv_CameraParam[0]) != 0.0)))
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanDivision;
                    (*hv_CameraType) = "area_scan_division";
                }
                else
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanTelecentricDivisionLegacy;
                    (*hv_CameraType) = "area_scan_telecentric_division";
                }
                break;
            case 10:
                // CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'
                if (0 != (int(HTuple(hv_CameraParam[0]) != 0.0)))
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanTiltDivisionLegacy;
                    (*hv_CameraType) = "area_scan_tilt_division";
                }
                else
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
                    (*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_division";
                }
                break;
            case 12:
                // CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'
                if (0 != (int(HTuple(hv_CameraParam[0]) != 0.0)))
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanPolynomial;
                    (*hv_CameraType) = "area_scan_polynomial";
                }
                else
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanTelecentricPolynomialLegacy;
                    (*hv_CameraType) = "area_scan_telecentric_polynomial";
                }
                break;
            case 14:
                // CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'
                if (0 != (int(HTuple(hv_CameraParam[0]) != 0.0)))
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanTiltPolynomialLegacy;
                    (*hv_CameraType) = "area_scan_tilt_polynomial";
                }
                else
                {
                    (*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;
                    (*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_polynomial";
                }
                break;
                //
                // Line Scan
            case 11:
                // CameraType: 'line_scan' or 'line_scan_telecentric'
                if (0 != (int(HTuple(hv_CameraParam[0]) != 0.0)))
                {
                    (*hv_ParamNames) = hv_CameraParamLinesScanDivision;
                    (*hv_CameraType) = "line_scan_division";
                }
                else
                {
                    (*hv_ParamNames) = hv_CameraParamLinesScanTelecentricDivision;
                    (*hv_CameraType) = "line_scan_telecentric_division";
                }
                break;
            default:
                throw HException("Wrong number of values in CameraParam.");
            }
        }
        else
        {
            // Format of camera parameters since HALCON 13
            (*hv_CameraType) = ((const HTuple &)hv_CameraParam)[0];
            if (0 != (int((*hv_CameraType) == HTuple("area_scan_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 9)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 13)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_telecentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 9)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_telecentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 13)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 12)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 16)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 11)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 15)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 11)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 15)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 12)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 16)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_hypercentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 9)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("area_scan_hypercentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 13)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricPolynomial);
            }
            else if (0 != (HTuple(int((*hv_CameraType) == HTuple("line_scan_division"))).TupleOr(int((*hv_CameraType) == HTuple("line_scan")))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 12)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 16)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanPolynomial);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_telecentric_division"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 12)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanTelecentricDivision);
            }
            else if (0 != (int((*hv_CameraType) == HTuple("line_scan_telecentric_polynomial"))))
            {
                if (0 != (int((hv_CameraParam.TupleLength()) != 16)))
                {
                    throw HException("Wrong number of values in CameraParam.");
                }
                (*hv_ParamNames).Clear();
                (*hv_ParamNames)[0] = "camera_type";
                (*hv_ParamNames).Append(hv_CameraParamLinesScanTelecentricPolynomial);
            }
            else
            {
                throw HException("Unknown camera type in CameraParam.");
            }
        }
        return;
    }

    // Chapter: Graphics / Output
    // Short Description: Compute the center of all given 3D object models.
    void get_object_models_center(HTuple hv_ObjectModel3DID, HTuple *hv_Center)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Diameters, hv_Index, hv_Diameter, hv_C;
        HTuple hv_Exception, hv_MD, hv_Weight, hv_SumW, hv_ObjectModel3DIDSelected;
        HTuple hv_InvSum;

        // Compute the mean of all model centers (weighted by the diameter of the object models)
        hv_Diameters = HTuple(hv_ObjectModel3DID.TupleLength(), 0.0);
        {
            HTuple end_val2 = (hv_ObjectModel3DID.TupleLength()) - 1;
            HTuple step_val2 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val2, step_val2); hv_Index += step_val2)
            {
                try
                {
                    GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "diameter_axis_aligned_bounding_box",
                                           &hv_Diameter);
                    GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "center", &hv_C);
                    hv_Diameters[hv_Index] = hv_Diameter;
                }
                // catch (Exception)
                catch (HException &HDevExpDefaultException)
                {
                    HDevExpDefaultException.ToHTuple(&hv_Exception);
                    // Object model is empty, has no center etc. -> ignore it by leaving its diameter at zero
                }
            }
        }

        if (0 != (int((hv_Diameters.TupleSum()) > 0)))
        {
            // Normalize Diameter to use it as weights for a weighted mean of the individual centers
            hv_MD = (hv_Diameters.TupleSelectMask(hv_Diameters.TupleGreaterElem(0))).TupleMean();
            if (0 != (int(hv_MD > 1e-10)))
            {
                hv_Weight = hv_Diameters / hv_MD;
            }
            else
            {
                hv_Weight = hv_Diameters;
            }
            hv_SumW = hv_Weight.TupleSum();
            if (0 != (int(hv_SumW < 1e-10)))
            {
                hv_Weight = HTuple(hv_Weight.TupleLength(), 1.0);
                hv_SumW = hv_Weight.TupleSum();
            }
            (*hv_Center).Clear();
            (*hv_Center)[0] = 0;
            (*hv_Center)[1] = 0;
            (*hv_Center)[2] = 0;
            {
                HTuple end_val26 = (hv_ObjectModel3DID.TupleLength()) - 1;
                HTuple step_val26 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val26, step_val26); hv_Index += step_val26)
                {
                    if (0 != (int(HTuple(hv_Diameters[hv_Index]) > 0)))
                    {
                        hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3DID[hv_Index]);
                        GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", &hv_C);
                        (*hv_Center)[0] = HTuple((*hv_Center)[0]) + (HTuple(hv_C[0]) * HTuple(hv_Weight[hv_Index]));
                        (*hv_Center)[1] = HTuple((*hv_Center)[1]) + (HTuple(hv_C[1]) * HTuple(hv_Weight[hv_Index]));
                        (*hv_Center)[2] = HTuple((*hv_Center)[2]) + (HTuple(hv_C[2]) * HTuple(hv_Weight[hv_Index]));
                    }
                }
            }
            hv_InvSum = 1.0 / hv_SumW;
            (*hv_Center)[0] = HTuple((*hv_Center)[0]) * hv_InvSum;
            (*hv_Center)[1] = HTuple((*hv_Center)[1]) * hv_InvSum;
            (*hv_Center)[2] = HTuple((*hv_Center)[2]) * hv_InvSum;
        }
        else
        {
            (*hv_Center) = HTuple();
        }
        return;
    }

    void get_object_pose(HTuple hv_ObjectModel3DRigidTrans, HTuple hv_CamParam, HTuple *hv_Pose2)
    {

        // Local control variables
        HTuple hv_Center1, hv_PoseIn;

        get_object_models_center(hv_ObjectModel3DRigidTrans, &hv_Center1);
        CreatePose(-HTuple(hv_Center1[0]), -HTuple(hv_Center1[1]), -HTuple(hv_Center1[2]),
                   0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
        determine_optimum_pose_distance(hv_ObjectModel3DRigidTrans, hv_CamParam, 0.2, hv_PoseIn,
                                        &(*hv_Pose2));
        return;
    }

    void getWLSWeight(HTuple hv_MatA, HTuple hv_MeanPoint, HTuple hv_lineVec, HTuple *hv_MatW2)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Rows2, hv_Columns2, hv_Delta, hv_I;
        HTuple hv_Value, hv_Diff, hv_Vector1, hv_Prod, hv_Sum;
        HTuple hv_Norm, hv_Prod1, hv_arryW, hv_Sum1, hv_MeanDelta;
        HTuple hv_DifDel, hv_Prod2, hv_Sum2, hv_Quot, hv_DeltaStd;
        HTuple hv_MaxDis, hv_J;

        GetSizeMatrix(hv_MatA, &hv_Rows2, &hv_Columns2);
        hv_Delta = HTuple();
        {
            HTuple end_val2 = hv_Rows2 - 1;
            HTuple step_val2 = 1;
            for (hv_I = 0; hv_I.Continue(end_val2, step_val2); hv_I += step_val2)
            {
                GetValueMatrix(hv_MatA, (hv_I.TupleConcat(hv_I)).TupleConcat(hv_I), ((HTuple(0).Append(1)).Append(2)),
                               &hv_Value);
                TupleSub(hv_Value, hv_MeanPoint, &hv_Diff);
                CrossMultFunc(hv_Diff, hv_lineVec, &hv_Vector1);
                TupleMult(hv_Vector1, hv_Vector1, &hv_Prod);
                TupleSum(hv_Prod, &hv_Sum);
                hv_Norm = (HTuple(1e-8).TupleConcat(hv_Sum.TupleSqrt())).TupleMax();
                hv_Delta = hv_Delta.TupleConcat(hv_Norm);
            }
        }

        TupleMult(hv_Delta, hv_Delta, &hv_Prod1);
        TupleDiv(1, hv_Prod1, &hv_arryW);

        TupleSum(hv_Delta, &hv_Sum1);
        hv_MeanDelta = hv_Sum1 / hv_Rows2;

        TupleSub(hv_Delta, hv_MeanDelta, &hv_DifDel);
        TupleMult(hv_DifDel, hv_DifDel, &hv_Prod2);
        TupleSum(hv_Prod2, &hv_Sum2);
        TupleDiv(hv_Sum2, hv_Rows2, &hv_Quot);
        TupleSqrt(hv_Quot, &hv_DeltaStd);
        hv_MaxDis = hv_DeltaStd / 2;
        {
            HTuple end_val25 = hv_Rows2 - 1;
            HTuple step_val25 = 1;
            for (hv_J = 0; hv_J.Continue(end_val25, step_val25); hv_J += step_val25)
            {
                if (0 != (int(((HTuple(hv_Delta[hv_J]) - hv_MeanDelta).TupleAbs()) > hv_MaxDis)))
                {
                    hv_arryW[hv_J] = 0;
                }
            }
        }
        CreateMatrix(hv_Rows2, hv_Rows2, hv_arryW, &(*hv_MatW2));
        return;
    }

    void LineIntersec3D(HTuple hv_MeanPointUp, HTuple hv_lineVecUp, HTuple hv_MeanPointRight,
                        HTuple hv_lineVecRight, HTuple *hv_IntersecPonit, int *hv_Result)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_VectorCross, hv_DotA, hv_DotB, hv_DotC;
        HTuple hv_DiffP, hv_DotD, hv_DotE, hv_DenomCoe, hv_MolecCoe;
        HTuple hv_T1, hv_T2, hv_Prod1, hv_ProdUp, hv_Prod11, hv_ProdRight;
        HTuple hv_Sum;
        hv_Result = (int *)1;
        (*hv_IntersecPonit).Clear();
        (*hv_IntersecPonit)[0] = 0;
        (*hv_IntersecPonit)[1] = 0;
        (*hv_IntersecPonit)[2] = 0;
        //*两条线的交点如何求？1. 公垂线；2.最短的公垂线与两条线的交点？
        CrossMultFunc(hv_lineVecUp, hv_lineVecRight, &hv_VectorCross);

        //*计算公垂线在上侧直线和右侧直线的垂足
        DotVector(hv_lineVecUp, hv_lineVecRight, &hv_DotA);
        DotVector(hv_lineVecUp, hv_lineVecUp, &hv_DotB);
        DotVector(hv_lineVecRight, hv_lineVecRight, &hv_DotC);

        TupleSub(hv_MeanPointRight, hv_MeanPointUp, &hv_DiffP);
        DotVector(hv_DiffP, hv_lineVecUp, &hv_DotD);
        DotVector(hv_DiffP, hv_lineVecRight, &hv_DotE);
        hv_DenomCoe = (hv_DotA * hv_DotA) - (hv_DotB * hv_DotC);
        hv_MolecCoe = (hv_DotA * hv_DotE) - (hv_DotD * hv_DotC);
        if (0 != (int(hv_DotA == 0)))
        {
            hv_T1 = hv_DotD / hv_DotB;
            hv_T2 = (-hv_DotE) / hv_DotC;
        }
        else if (0 != (int((hv_DenomCoe.TupleAbs()) <= 0.001)))
        {
            //*两个直线平行或者重合
            hv_Result = (int *)-1; //, 两个直线平行或重合，请确认
        }
        else
        {
            hv_T1 = hv_MolecCoe / hv_DenomCoe;
            hv_T2 = ((hv_DotB * hv_T1) / hv_DotA) - (hv_DotD / hv_DotA);
        }

        //*代入直线方程计算公垂线端点坐标
        TupleMult(hv_lineVecUp, hv_T1, &hv_Prod1);
        TupleAdd(hv_MeanPointUp, hv_Prod1, &hv_ProdUp);

        TupleMult(hv_lineVecRight, hv_T2, &hv_Prod11);
        TupleAdd(hv_MeanPointRight, hv_Prod11, &hv_ProdRight);

        //两个端点中点
        TupleAdd(hv_ProdRight, hv_ProdUp, &hv_Sum);
        TupleDiv(hv_Sum, 2, &(*hv_IntersecPonit));
        return;
    }

    void LineQuality_3D(HTuple hv_LineUpX, HTuple hv_LineUpY, HTuple hv_LineUpZ, HTuple hv_MeanPointUp,
                        HTuple hv_lineVecUp, HTuple *hv_DistUp, HTuple *hv_MedianUp, HTuple *hv_DeviationUp)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_I, hv_TmpPoint, hv_PP0, hv_CrossP;
        HTuple hv_Prod, hv_Sum, hv_Dist;

        (*hv_DistUp) = HTuple();
        {
            HTuple end_val1 = (hv_LineUpX.TupleLength()) - 1;
            HTuple step_val1 = 1;
            for (hv_I = 0; hv_I.Continue(end_val1, step_val1); hv_I += step_val1)
            {
                //*MeanPointUp, lineVecUp
                hv_TmpPoint.Clear();
                hv_TmpPoint.Append(HTuple(hv_LineUpX[hv_I]));
                hv_TmpPoint.Append(HTuple(hv_LineUpY[hv_I]));
                hv_TmpPoint.Append(HTuple(hv_LineUpZ[hv_I]));
                TupleSub(hv_MeanPointUp, hv_TmpPoint, &hv_PP0);
                CrossMultFunc(hv_PP0, hv_lineVecUp, &hv_CrossP);
                TupleMult(hv_CrossP, hv_CrossP, &hv_Prod);
                TupleSum(hv_Prod, &hv_Sum);
                hv_Dist = hv_Sum.TupleSqrt();
                (*hv_DistUp) = (*hv_DistUp).TupleConcat(hv_Dist);
            }
        }
        TupleMedian((*hv_DistUp), &(*hv_MedianUp));
        TupleDeviation((*hv_DistUp), &(*hv_DeviationUp));
        return;
    }

    void MeasureHeight(HObject ho_RegionFillUp, HObject ho_ImageReduced1, HObject ho_ImageReduced2,
                       HObject ho_ImageReduced3, HObject ho_ZResult, HObject ho_Rectangle, HTuple hv_Rows,
                       HTuple hv_Columns, HTuple hv_tuple_Phi, HTuple hv_tuple_Len1, HTuple hv_tuple_Len2,
                       HTuple hv_MaxTh, HTuple hv_MinTh, HTuple *hv_Height3D, HTuple *hv_LineUpX, HTuple *hv_LineUpY,
                       HTuple *hv_LineUpZ, HTuple *hv_LineDownX, HTuple *hv_LineDownY, HTuple *hv_LineDownZ)
    {

        // Local iconic variables
        HObject ho_Contours, ho_Circle, ho_RegionIntersection;
        HObject ho_RegionIntersection1;

        // Local control variables
        HTuple hv_Width, hv_Height, hv_Index, hv_MeasureHandle;
        HTuple hv_RowEdge, hv_ColumnEdge, hv_Amplitude, hv_Distance;
        HTuple hv_Len, hv_Radius, hv_MeanX, hv_Deviation, hv_MeanY;
        HTuple hv_Deviation1, hv_MeanZ, hv_Deviation2, hv_MeanX1;
        HTuple hv_MeanY1, hv_MeanZ1, hv_UPLine, hv_DownLine, hv_Distance3D;
        HTuple hv_DistanceMin, hv_DistanceMax, hv_DistanceMin2;

        (*hv_Height3D) = HTuple();
        (*hv_LineUpX) = HTuple();
        (*hv_LineUpY) = HTuple();
        (*hv_LineUpZ) = HTuple();
        (*hv_LineDownX) = HTuple();
        (*hv_LineDownY) = HTuple();
        (*hv_LineDownZ) = HTuple();
        // LinePose := []
        GenContourRegionXld(ho_Rectangle, &ho_Contours, "border");
        GetImageSize(ho_ImageReduced3, &hv_Width, &hv_Height);
        {
            HTuple end_val10 = (hv_Rows.TupleLength()) - 1;
            HTuple step_val10 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val10, step_val10); hv_Index += step_val10)
            {
                // tuple_deg (tuple_Phi, Deg)
                // gen_rectangle2 (Rect, Rows[Index], Columns[Index], tuple_Phi[Index], tuple_Len1[Index], tuple_Len2[Index])
                GenMeasureRectangle2(HTuple(hv_Rows[hv_Index]), HTuple(hv_Columns[hv_Index]),
                                     HTuple(hv_tuple_Phi[hv_Index]), HTuple(hv_tuple_Len1[hv_Index]), HTuple(hv_tuple_Len2[hv_Index]),
                                     hv_Width, hv_Height, "nearest_neighbor", &hv_MeasureHandle);
                MeasurePos(ho_ZResult, hv_MeasureHandle, 1, 15, "all", "all", &hv_RowEdge, &hv_ColumnEdge,
                           &hv_Amplitude, &hv_Distance);
                //*下侧边缘坐标计算
                hv_Len = hv_RowEdge.TupleLength();
                if (0 != (int(hv_Len > 0)))
                {
                    //*上侧边缘坐标
                    hv_Radius = 3;
                    GenCircle(&ho_Circle, HTuple(hv_RowEdge[0]), HTuple(hv_ColumnEdge[0]), hv_Radius);

                    Intersection(ho_Circle, ho_RegionFillUp, &ho_RegionIntersection);
                    Intensity(ho_RegionIntersection, ho_ImageReduced1, &hv_MeanX, &hv_Deviation);
                    Intensity(ho_RegionIntersection, ho_ImageReduced2, &hv_MeanY, &hv_Deviation1);
                    Intensity(ho_RegionIntersection, ho_ImageReduced3, &hv_MeanZ, &hv_Deviation2);
                    while (0 != (int(hv_MeanZ == 0)))
                    {
                        hv_Radius += 3;
                        GenCircle(&ho_Circle, HTuple(hv_RowEdge[0]), HTuple(hv_ColumnEdge[0]), hv_Radius);
                        Intersection(ho_Circle, ho_RegionFillUp, &ho_RegionIntersection);
                        Intensity(ho_RegionIntersection, ho_ImageReduced1, &hv_MeanX, &hv_Deviation);
                        Intensity(ho_RegionIntersection, ho_ImageReduced2, &hv_MeanY, &hv_Deviation1);
                        Intensity(ho_RegionIntersection, ho_ImageReduced3, &hv_MeanZ, &hv_Deviation2);
                    }
                    hv_Radius = 3;
                    GenCircle(&ho_Circle, HTuple(hv_RowEdge[hv_Len - 1]), HTuple(hv_ColumnEdge[hv_Len - 1]),
                              hv_Radius);
                    Intersection(ho_Circle, ho_RegionFillUp, &ho_RegionIntersection1);
                    Intensity(ho_RegionIntersection1, ho_ImageReduced1, &hv_MeanX1, &hv_Deviation);
                    Intensity(ho_RegionIntersection1, ho_ImageReduced2, &hv_MeanY1, &hv_Deviation1);
                    Intensity(ho_RegionIntersection1, ho_ImageReduced3, &hv_MeanZ1, &hv_Deviation2);

                    while (0 != (int(hv_MeanZ1 == 0)))
                    {
                        hv_Radius += 3;
                        GenCircle(&ho_Circle, HTuple(hv_RowEdge[hv_Len - 1]), HTuple(hv_ColumnEdge[hv_Len - 1]),
                                  hv_Radius);
                        Intersection(ho_Circle, ho_RegionFillUp, &ho_RegionIntersection1);
                        Intensity(ho_RegionIntersection1, ho_ImageReduced1, &hv_MeanX1, &hv_Deviation);
                        Intensity(ho_RegionIntersection1, ho_ImageReduced2, &hv_MeanY1, &hv_Deviation1);
                        Intensity(ho_RegionIntersection1, ho_ImageReduced3, &hv_MeanZ1, &hv_Deviation2);
                    }

                    if (0 != (HTuple(HTuple(HTuple(int(hv_MeanZ1 < hv_MaxTh)).TupleAnd(int(hv_MeanZ1 > hv_MinTh))).TupleAnd(int(hv_MeanZ < hv_MaxTh))).TupleAnd(int(hv_MeanZ > hv_MinTh))))
                    {
                        hv_UPLine.Clear();
                        hv_UPLine.Append(hv_MeanX);
                        hv_UPLine.Append(hv_MeanY);
                        hv_UPLine.Append(hv_MeanZ);
                        hv_DownLine.Clear();
                        hv_DownLine.Append(hv_MeanX1);
                        hv_DownLine.Append(hv_MeanY1);
                        hv_DownLine.Append(hv_MeanZ1);
                        distance_3d_pp(hv_UPLine, hv_DownLine, &hv_Distance3D);
                        (*hv_Height3D) = (*hv_Height3D).TupleConcat(hv_Distance3D);
                        if (0 != (HTuple(int(hv_Index > 10)).TupleAnd(int(hv_Index < ((hv_Rows.TupleLength()) - 11)))))
                        {
                            //*判断点是在否在右侧/上侧
                            DistancePc(ho_Contours, HTuple(hv_RowEdge[0]), HTuple(hv_ColumnEdge[0]),
                                       &hv_DistanceMin, &hv_DistanceMax);
                            DistancePc(ho_Contours, HTuple(hv_RowEdge[hv_Len - 1]), HTuple(hv_ColumnEdge[hv_Len - 1]),
                                       &hv_DistanceMin2, &hv_DistanceMax);
                            if (0 != (int((hv_DistanceMin.TupleAbs()) < (hv_DistanceMin2.TupleAbs()))))
                            {
                                //*点在右侧/上侧
                                (*hv_LineUpX) = (*hv_LineUpX).TupleConcat(hv_MeanX);
                                (*hv_LineUpY) = (*hv_LineUpY).TupleConcat(hv_MeanY);
                                (*hv_LineUpZ) = (*hv_LineUpZ).TupleConcat(hv_MeanZ);
                                (*hv_LineDownX) = (*hv_LineDownX).TupleConcat(hv_MeanX1);
                                (*hv_LineDownY) = (*hv_LineDownY).TupleConcat(hv_MeanY1);
                                (*hv_LineDownZ) = (*hv_LineDownZ).TupleConcat(hv_MeanZ1);
                            }
                            else
                            {
                                //*点在右侧/上侧
                                (*hv_LineUpX) = (*hv_LineUpX).TupleConcat(hv_MeanX1);
                                (*hv_LineUpY) = (*hv_LineUpY).TupleConcat(hv_MeanY1);
                                (*hv_LineUpZ) = (*hv_LineUpZ).TupleConcat(hv_MeanZ1);
                                (*hv_LineDownX) = (*hv_LineDownX).TupleConcat(hv_MeanX);
                                (*hv_LineDownY) = (*hv_LineDownY).TupleConcat(hv_MeanY);
                                (*hv_LineDownZ) = (*hv_LineDownZ).TupleConcat(hv_MeanZ);
                            }
                        }
                        // LinePose := [LinePose, [UPLine[0:2],0,0,0,0], [DownLine[0:2],0,0,0,0]]
                    }
                }
            }
        }

        return;
    }

    void Rect2Corner(HTuple hv_CenterY, HTuple hv_CenterX, HTuple hv_Phi, HTuple hv_Len1,
                     HTuple hv_Len2, HTuple *hv_CornerY, HTuple *hv_CornerX)
    {

        // Local iconic variables
        HObject ho_Cross, ho_Cross1, ho_Cross2, ho_Cross3;

        // Local control variables
        HTuple hv_Cos, hv_Sin, hv_ColT, hv_RowT;

        //计算仿射矩形的正弦值、余弦值
        TupleCos(hv_Phi, &hv_Cos);
        TupleSin(hv_Phi, &hv_Sin);
        //矩形端点坐标、边中心坐标初始化
        (*hv_CornerY) = HTuple();
        (*hv_CornerX) = HTuple();
        //矩形第一个端点计算（左上）
        hv_ColT = (hv_CenterX - (hv_Len1 * hv_Cos)) - (hv_Len2 * hv_Sin);
        hv_RowT = hv_CenterY - (((-hv_Len1) * hv_Sin) + (hv_Len2 * hv_Cos));
        (*hv_CornerY) = (*hv_CornerY).TupleConcat(hv_RowT);
        (*hv_CornerX) = (*hv_CornerX).TupleConcat(hv_ColT);
        GenCrossContourXld(&ho_Cross, hv_RowT, hv_ColT, 6, 0);

        //矩形第二个端点计算（右上）
        hv_ColT = (hv_CenterX + (hv_Len1 * hv_Cos)) - (hv_Len2 * hv_Sin);
        hv_RowT = hv_CenterY - ((hv_Len1 * hv_Sin) + (hv_Len2 * hv_Cos));
        (*hv_CornerY) = (*hv_CornerY).TupleConcat(hv_RowT);
        (*hv_CornerX) = (*hv_CornerX).TupleConcat(hv_ColT);
        GenCrossContourXld(&ho_Cross1, hv_RowT, hv_ColT, 6, 0);

        //矩形第三个端点计算（右下）
        hv_ColT = (hv_CenterX + (hv_Len1 * hv_Cos)) + (hv_Len2 * hv_Sin);
        hv_RowT = hv_CenterY - ((hv_Len1 * hv_Sin) - (hv_Len2 * hv_Cos));
        (*hv_CornerY) = (*hv_CornerY).TupleConcat(hv_RowT);
        (*hv_CornerX) = (*hv_CornerX).TupleConcat(hv_ColT);
        GenCrossContourXld(&ho_Cross2, hv_RowT, hv_ColT, 6, 0);

        //矩形的第四个端点计算（左下）
        hv_ColT = (hv_CenterX - (hv_Len1 * hv_Cos)) + (hv_Len2 * hv_Sin);
        hv_RowT = hv_CenterY - (((-hv_Len1) * hv_Sin) - (hv_Len2 * hv_Cos));
        (*hv_CornerY) = (*hv_CornerY).TupleConcat(hv_RowT);
        (*hv_CornerX) = (*hv_CornerX).TupleConcat(hv_ColT);
        GenCrossContourXld(&ho_Cross3, hv_RowT, hv_ColT, 6, 0);

        return;
    }

    void SortCorner(HTuple hv_RightUpPoint, HTuple hv_RightUpPoint2, HTuple hv_RightDownPoint2,
                    HTuple hv_LeftUpPoint2, HTuple hv_LeftDownPoint2, HTuple hv_RightDown1, HTuple hv_RightUp1,
                    HTuple hv_LeftUp1, HTuple hv_LeftDown1, HTuple *hv_RightUp)
    {

        // Local iconic variables

        if (0 != (int(hv_RightUpPoint == hv_RightUpPoint2)))
        {
            (*hv_RightUp) = hv_RightUp1;
        }
        else if (0 != (int(hv_RightUpPoint == hv_RightDownPoint2)))
        {
            (*hv_RightUp) = hv_RightDown1;
        }
        else if (0 != (int(hv_RightUpPoint == hv_LeftUpPoint2)))
        {
            (*hv_RightUp) = hv_LeftUp1;
        }
        else if (0 != (int(hv_RightUpPoint == hv_LeftDownPoint2)))
        {
            (*hv_RightUp) = hv_LeftDown1;
        }
        return;
    }

    void UnitVector(HTuple hv_LeftUpPoint, HTuple hv_LeftDownPoint, HTuple *hv_LeftUnitVec)
    {

        // Local control variables
        HTuple hv_LeftVec, hv_Prod, hv_Sum;

        TupleSub(hv_LeftUpPoint, hv_LeftDownPoint, &hv_LeftVec);
        //*向量单位化
        TupleMult(hv_LeftVec, hv_LeftVec, &hv_Prod);
        TupleSum(hv_Prod, &hv_Sum);
        TupleDiv(hv_LeftVec, hv_Sum.TupleSqrt(), &(*hv_LeftUnitVec));
        return;
    }

    void VectorPoint_3rd_trans(HTuple hv_HomMat3D, HTuple hv_HomMat3D1, HTuple hv_HomMat3D2,
                               HTuple hv_RightUpPoint1, HTuple *hv_RightUpPoint)
    {

        // Local iconic variables

        // Local control variables
        HTuple hv_Qx31, hv_Qy31, hv_Qz31, hv_Qx32, hv_Qy32;
        HTuple hv_Qz32, hv_Qx33, hv_Qy33, hv_Qz33;

        AffineTransPoint3d(hv_HomMat3D, HTuple(hv_RightUpPoint1[0]), HTuple(hv_RightUpPoint1[1]),
                           HTuple(hv_RightUpPoint1[2]), &hv_Qx31, &hv_Qy31, &hv_Qz31);
        AffineTransPoint3d(hv_HomMat3D1, hv_Qx31, hv_Qy31, hv_Qz31, &hv_Qx32, &hv_Qy32,
                           &hv_Qz32);
        AffineTransPoint3d(hv_HomMat3D2, hv_Qx32, hv_Qy32, hv_Qz32, &hv_Qx33, &hv_Qy33,
                           &hv_Qz33);
        (*hv_RightUpPoint).Clear();
        (*hv_RightUpPoint).Append(hv_Qx33);
        (*hv_RightUpPoint).Append(hv_Qy33);
        (*hv_RightUpPoint).Append(hv_Qz33);
        return;
    }

    void VectorPoints_3rd_trans(HTuple hv_LineUpX1, HTuple hv_LineUpY1, HTuple hv_LineUpZ1,
                                HTuple hv_HomMat3D, HTuple hv_HomMat3D1, HTuple hv_HomMat3D2, HTuple *hv_LineUpX,
                                HTuple *hv_LineUpY, HTuple *hv_LineUpZ)
    {

        // Local control variables
        HTuple hv_Qx31, hv_Qy31, hv_Qz31, hv_Qx32, hv_Qy32;
        HTuple hv_Qz32;

        AffineTransPoint3d(hv_HomMat3D, hv_LineUpX1, hv_LineUpY1, hv_LineUpZ1, &hv_Qx31,
                           &hv_Qy31, &hv_Qz31);
        AffineTransPoint3d(hv_HomMat3D1, hv_Qx31, hv_Qy31, hv_Qz31, &hv_Qx32, &hv_Qy32,
                           &hv_Qz32);
        AffineTransPoint3d(hv_HomMat3D2, hv_Qx32, hv_Qy32, hv_Qz32, &(*hv_LineUpX), &(*hv_LineUpY),
                           &(*hv_LineUpZ));
        return;
    }
    void Line3D_Angle(HTuple hv_lineVecRight, HTuple hv_lineVecUp, HTuple *hv_AngleUR)
    {

        HTuple hv_CosUR, hv_ACos;

        DotVector(hv_lineVecRight, hv_lineVecUp, &hv_CosUR);
        TupleAcos(hv_CosUR, &hv_ACos);
        (*hv_AngleUR) = hv_ACos.TupleDeg();

        return;
    }
    void HeightAndPoseVector(HTuple hv_CamParam, double hv_SetParas[6], HTuple hv_ObjectModel3D, double &MedianHeight, double &MedianWidth, double *VectorPosition, double *IntersecPonitUR,
                             double *IntersecPonitUL, double *IntersecPonitDR, double *IntersecPonitDL, double *LineQuali, std::string &Result)
    {

        // Local iconic variables
        HObject ho_X1, ho_Y1, ho_Z1, ho_Domain, ho_RegionOpening1;
        HObject ho_RegionErosion, ho_ImageReduced, ho_ImageReduced4;
        HObject ho_ImageReduced5, ho_X, ho_Y, ho_Z, ho_ImageMean;
        HObject ho_Region, ho_RegionOpening, ho_ConnectedRegions;
        HObject ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2;
        HObject ho_ImageReduced3, ho_RegionDifference1, ho_ZResult;
        HObject ho_Rectangle1, ho_Rectangle2;

        // Local control variables
        HTuple hv_RightPoint, hv_IntersecPonitUL, hv_IntersecPonitDR, hv_IntersecPonitDL;
        HTuple hv_ObjectModel3DZ1, hv_ObjectModel3DZ;
        HTuple hv_ObjectModel3DConnected, hv_GenParamValue, hv_ObjectModel3DSelected;
        HTuple hv_Pose, hv_PoseInvert, hv_ObjectModel3DRigidTrans;
        HTuple hv_Pose2, hv_ObjectModel3D1, hv_Width, hv_Height;
        HTuple hv_Row1, hv_Column1, hv_Phi1, hv_Length11, hv_Length21;
        HTuple hv_ObjectModel3D4, hv_PoseInvert1, hv_ObjectModel3DRigidTrans1;
        HTuple hv_MomentsPose, hv_PoseInvert3, hv_ObjectModel3DRigidTrans3;
        HTuple hv_PoseEstimated, hv_ObjectModel3D2, hv_AZrea, hv_Row2;
        HTuple hv_Column2, hv_Mean1, hv_Deviation4, hv_Devi, hv_MinTh;
        HTuple hv_MaxTh, hv_Mean, hv_Deviation3, hv_Row, hv_Column;
        HTuple hv_Phi, hv_Length1, hv_Length2, hv_RowCorner, hv_ColCorner;
        HTuple hv_LeftUp1, hv_LeftDown1, hv_RightUp1, hv_RightDown1;
        HTuple hv_LeftUpPoint1, hv_RightUpPoint1, hv_RightDownPoint1;
        HTuple hv_LeftDownPoint1, hv_PoseInvert11, hv_HomMat3D;
        HTuple hv_HomMat3D1, hv_HomMat3D2, hv_NormalsVector1, hv_Qx52;
        HTuple hv_Qy52, hv_Qz52, hv_Qx53, hv_Qy53, hv_Qz53, hv_NormalsVector2;
        HTuple hv_VectorX, hv_LeftUpPoint2, hv_LeftDownPoint2;
        HTuple hv_RightUpPoint2, hv_RightDownPoint2, hv_PositionX;
        HTuple hv_PositionY, hv_PositionZ, hv_Indices, hv_LeftRowCorner;
        HTuple hv_LeftColCorner, hv_LeftZCorner, hv_Indices1, hv_VectorY;
        HTuple hv_VectorZ, hv_RightRowCorner, hv_RightColCorner;
        HTuple hv_RightZCorner, hv_RightUpPoint, hv_RightDownPoint;
        HTuple hv_RightUp, hv_RightDown, hv_LeftUp, hv_LeftDown;
        HTuple hv_MeasureWidth, hv_Rows, hv_Columns, hv_tuple_Phi;
        HTuple hv_tuple_Len1, hv_tuple_Len2, hv_UpCenterRow, hv_UpCenterCol;
        HTuple hv_LengthU, hv_PhiU, hv_Height3D, hv_LineUpX1, hv_LineUpY1;
        HTuple hv_LineUpZ1, hv_LineDownX1, hv_LineDownY1, hv_LineDownZ1;
        HTuple hv_Rows1, hv_Columns1, hv_tuple_Phi1, hv_tuple_Len11;
        HTuple hv_tuple_Len21, hv_RightCenterRow, hv_RightCenterCol;
        HTuple hv_LengthR, hv_PhiR, hv_Width3D, hv_LineRightX1;
        HTuple hv_LineRightY1, hv_LineRightZ1, hv_LineLeftX1, hv_LineLeftY1;
        HTuple hv_LineLeftZ1, hv_LineUpX, hv_LineUpY, hv_LineUpZ;
        HTuple hv_LineDownX, hv_LineDownY, hv_LineDownZ, hv_LineLeftX;
        HTuple hv_LineLeftY, hv_LineLeftZ, hv_LineRightX, hv_LineRightY;
        HTuple hv_LineRightZ, hv_MeanPointUp, hv_lineVecUp, hv_MeanPointDown;
        HTuple hv_lineVecDown, hv_MeanPointLeft, hv_lineVecLeft;
        HTuple hv_MeanPointRight, hv_lineVecRight, hv_DistUp, hv_MedianUp;
        HTuple hv_DeviationUp, hv_DistDown, hv_MedianDown, hv_DeviationDown;
        HTuple hv_DistRight, hv_MedianRight, hv_DeviationRight;
        HTuple hv_DistLeft, hv_MedianLeft, hv_DeviationLeft, hv_DeviaDis, hv_Number;
        HTuple hv_Indices2, hv_Line, hv_Length, hv_Deep, hv_VectorY2, hv_Result, hv_Exception;
        int Result1 = 1;
        HTuple hv_VectorZ1, hv_VectorZ2, hv_VectorY1, hv_MedianWidth, hv_MedianHeight, hv_Length3;

        MedianHeight = 0;
        MedianWidth = 0;
        // VectorPosition[0,1,2,3,4,5,6,7,8] = 0;
        VectorPosition[0] = 0;
        VectorPosition[1] = 0;
        VectorPosition[2] = 0;
        VectorPosition[3] = 0;
        VectorPosition[4] = 0;
        VectorPosition[5] = 0;
        VectorPosition[6] = 0;
        VectorPosition[7] = 0;
        VectorPosition[8] = 0;
        IntersecPonitUR[0] = 0;
        IntersecPonitUR[1] = 0;
        IntersecPonitUR[2] = 0;
        IntersecPonitUL[0] = 0;
        IntersecPonitUL[1] = 0;
        IntersecPonitUL[2] = 0;
        IntersecPonitDR[0] = 0;
        IntersecPonitDR[1] = 0;
        IntersecPonitDR[2] = 0;
        IntersecPonitDL[0] = 0;
        IntersecPonitDL[1] = 0;
        IntersecPonitDL[2] = 0;
        LineQuali[0] = 0;
        LineQuali[1] = 0;
        LineQuali[2] = 0;
        LineQuali[3] = 0;
        Result = "1, 运行成功";

        try
        {
            /* code */

            SelectPointsObjectModel3d(hv_ObjectModel3D, "point_coord_z", HTuple(hv_SetParas[0]),
                                      HTuple(hv_SetParas[1]), &hv_ObjectModel3DZ1);
            SelectPointsObjectModel3d(hv_ObjectModel3DZ1, "point_coord_x", HTuple(hv_SetParas[2]),
                                      HTuple(hv_SetParas[3]), &hv_ObjectModel3DZ);
            ConnectionObjectModel3d(hv_ObjectModel3DZ, "distance_3d", HTuple(hv_SetParas[4]),
                                    &hv_ObjectModel3DConnected);
            GetObjectModel3dParams(hv_ObjectModel3DConnected, "num_points", &hv_GenParamValue);
            //*点云数量大于10万时，才认为采集没问题
            if (0 != (int((hv_GenParamValue.TupleMax()) > HTuple(hv_SetParas[5]))))
            {
                SelectObjectModel3d(hv_ObjectModel3DConnected, "num_points", "and", (hv_GenParamValue.TupleMax()) - 200,
                                    (hv_GenParamValue.TupleMax()) + 50, &hv_ObjectModel3DSelected);
                TupleLength(hv_ObjectModel3DSelected, &hv_Length3);

                if (0 != (int(hv_Length3 != 1)))
                {

                    //显示去噪后的目标区域
                    //*----------------------------------------------------------------2. 将点云集合变换到原始坐标系下主轴 x y z------------------------------
                    //*moments_object_model_3d中的 'central_moment_2_points'指的是二阶方差，前三个数是X Y Z的方差，后三个数是协方差结果，表示三个轴的关联性(xy xz yz)
                    MomentsObjectModel3d(hv_ObjectModel3DSelected, "principal_axes", &hv_Pose);
                    PoseInvert(hv_Pose, &hv_PoseInvert);
                    //**------方法2：刚性变换，等效于仿射变换
                    RigidTransObjectModel3d(hv_ObjectModel3DSelected, hv_PoseInvert, &hv_ObjectModel3DRigidTrans);

                    //*获取3D模型的姿态
                    get_object_pose(hv_ObjectModel3DRigidTrans, hv_CamParam, &hv_Pose2);
                    //*转换成X、Y、Z通道的图像
                    ObjectModel3dToXyz(&ho_X1, &ho_Y1, &ho_Z1, hv_ObjectModel3DRigidTrans, "cartesian",
                                       hv_CamParam, hv_Pose2);
                    XyzToObjectModel3d(ho_X1, ho_Y1, ho_Z1, &hv_ObjectModel3D1);
                    //**Blolb处理去除边界干扰，抠出在一个平面的目标点云
                    GetDomain(ho_Z1, &ho_Domain);
                    GetImageSize(ho_Z1, &hv_Width, &hv_Height);
                    SmallestRectangle2(ho_Domain, &hv_Row1, &hv_Column1, &hv_Phi1, &hv_Length11,
                                       &hv_Length21);
                    OpeningCircle(ho_Domain, &ho_RegionOpening1, 3.5);
                    ErosionRectangle1(ho_RegionOpening1, &ho_RegionErosion, hv_Length11 / 3, hv_Length21 / 3);
                    ReduceDomain(ho_X1, ho_RegionErosion, &ho_ImageReduced);
                    ReduceDomain(ho_Y1, ho_RegionErosion, &ho_ImageReduced4);
                    ReduceDomain(ho_Z1, ho_RegionErosion, &ho_ImageReduced5);
                    XyzToObjectModel3d(ho_ImageReduced, ho_ImageReduced4, ho_ImageReduced5, &hv_ObjectModel3D4);

                    //*将抠出的平面反转回去，并计算出ObjectModel3DRigidTrans的实际主轴姿态，再对ObjectModel3DRigidTrans进行反转
                    PoseInvert(hv_Pose2, &hv_PoseInvert1);
                    RigidTransObjectModel3d(hv_ObjectModel3D4, hv_PoseInvert1, &hv_ObjectModel3DRigidTrans1);
                    MomentsObjectModel3d(hv_ObjectModel3DRigidTrans1, "principal_axes", &hv_MomentsPose);
                    PoseInvert(hv_MomentsPose, &hv_PoseInvert3);
                    RigidTransObjectModel3d(hv_ObjectModel3DRigidTrans, hv_PoseInvert3, &hv_ObjectModel3DRigidTrans3);

                    //*获取调平变换后的3D模型姿态
                    get_object_pose(hv_ObjectModel3DRigidTrans3, hv_CamParam, &hv_PoseEstimated);
                    //*将调平后的点云，再映射到X、Y、Z平面
                    ObjectModel3dToXyz(&ho_X, &ho_Y, &ho_Z, hv_ObjectModel3DRigidTrans3, "cartesian",
                                       hv_CamParam, hv_PoseEstimated);
                    XyzToObjectModel3d(ho_X, ho_Y, ho_Z, &hv_ObjectModel3D2);
                    //*获取在同一平面上的点云信息
                    GetDomain(ho_Z, &ho_Domain);
                    AreaCenter(ho_Domain, &hv_AZrea, &hv_Row2, &hv_Column2);
                    GetImageSize(ho_Z, &hv_Width, &hv_Height);
                    MeanImage(ho_Z, &ho_ImageMean, 1, 1);
                    Intensity(ho_Domain, ho_ImageMean, &hv_Mean1, &hv_Deviation4);
                    //*高度小于平均高度的区域
                    hv_Devi = hv_Deviation4 * 1.7;
                    if (0 != (int(hv_Devi < 40)))
                    {
                        hv_Devi = 40;
                    }
                    hv_MinTh = hv_Mean1 - hv_Devi;
                    hv_MaxTh = hv_Mean1 + hv_Devi;

                    //*在Z方向上确认深度突变的位置
                    Threshold(ho_Z, &ho_Region, hv_MinTh, hv_MaxTh);
                    OpeningCircle(ho_Region, &ho_RegionOpening, 1.5);
                    Connection(ho_RegionOpening, &ho_ConnectedRegions);
                    SelectShapeStd(ho_ConnectedRegions, &ho_RegionFillUp, "max_area", 70);
                    CountObj(ho_RegionFillUp, &hv_Number);

                    if (0 != (int(hv_Number == 1)))
                    {
                        ReduceDomain(ho_X, ho_RegionFillUp, &ho_ImageReduced1);
                        ReduceDomain(ho_Y, ho_RegionFillUp, &ho_ImageReduced2);
                        ReduceDomain(ho_Z, ho_RegionFillUp, &ho_ImageReduced3);
                        Intensity(ho_RegionFillUp, ho_ImageReduced3, &hv_Mean, &hv_Deviation3);

                        //*对目标区域喷涂，为了方便找边缘对
                        Difference(ho_Domain, ho_RegionFillUp, &ho_RegionDifference1);
                        PaintRegion(ho_RegionDifference1, ho_Z, &ho_ZResult, -99999, "fill");

                        SmallestRectangle2(ho_RegionFillUp, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1,
                                           &hv_Length2);

                        //**----------------------------------------------3.1.1 计算箱子的端点-------------------------------------------------
                        Rect2Corner(hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2, &hv_RowCorner,
                                    &hv_ColCorner);

                        hv_LeftUp1.Clear();
                        hv_LeftUp1.Append(HTuple(hv_RowCorner[0]));
                        hv_LeftUp1.Append(HTuple(hv_ColCorner[0]));
                        hv_LeftDown1.Clear();
                        hv_LeftDown1.Append(HTuple(hv_RowCorner[1]));
                        hv_LeftDown1.Append(HTuple(hv_ColCorner[1]));
                        hv_RightUp1.Clear();
                        hv_RightUp1.Append(HTuple(hv_RowCorner[2]));
                        hv_RightUp1.Append(HTuple(hv_ColCorner[2]));
                        hv_RightDown1.Clear();
                        hv_RightDown1.Append(HTuple(hv_RowCorner[3]));
                        hv_RightDown1.Append(HTuple(hv_ColCorner[3]));
                        //计算3D坐标下的结果
                        CalcuCornerPoint(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                         hv_LeftUp1, &hv_LeftUpPoint1);
                        CalcuCornerPoint(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                         hv_RightUp1, &hv_RightUpPoint1);
                        CalcuCornerPoint(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                         hv_RightDown1, &hv_RightDownPoint1);
                        CalcuCornerPoint(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                         hv_LeftDown1, &hv_LeftDownPoint1);

                        //*---------------------------------3.1.2计算左右两个棱向量对应的单位向量并显示---------------------------------
                        //*变换回到原始点云显示：先变换XYZ仿射前->然后变换到第二次中心矩变换前->再变换到第一次中心矩变换前
                        //*变换3D对应的四个端点和法向量RegionOpening1
                        PoseInvert(hv_PoseEstimated, &hv_PoseInvert11);
                        PoseToHomMat3d(hv_PoseInvert11, &hv_HomMat3D);
                        PoseToHomMat3d(hv_MomentsPose, &hv_HomMat3D1);
                        PoseToHomMat3d(hv_Pose, &hv_HomMat3D2);

                        hv_NormalsVector1 = hv_PoseInvert11.TupleSelectRange(0, 2);
                        AffineTransPoint3d(hv_HomMat3D1, HTuple(hv_NormalsVector1[0]), HTuple(hv_NormalsVector1[1]),
                                           HTuple(hv_NormalsVector1[2]), &hv_Qx52, &hv_Qy52, &hv_Qz52);
                        AffineTransPoint3d(hv_HomMat3D2, hv_Qx52, hv_Qy52, hv_Qz52, &hv_Qx53, &hv_Qy53,
                                           &hv_Qz53);
                        hv_NormalsVector2.Clear();
                        hv_NormalsVector2.Append(hv_Qx53);
                        hv_NormalsVector2.Append(hv_Qy53);
                        hv_NormalsVector2.Append(hv_Qz53);
                        //**单位化法向量:实际为箱体X轴方向
                        UnitVector(hv_NormalsVector2, ((HTuple(0).Append(0)).Append(0)), &hv_VectorX);

                        //* 左上角端点变换到原始点云下
                        VectorPoint_3rd_trans(hv_HomMat3D, hv_HomMat3D1, hv_HomMat3D2, hv_LeftUpPoint1,
                                              &hv_LeftUpPoint2);
                        //* 左下角端点变换到原始点云下
                        VectorPoint_3rd_trans(hv_HomMat3D, hv_HomMat3D1, hv_HomMat3D2, hv_LeftDownPoint1,
                                              &hv_LeftDownPoint2);
                        //* 右上角端点变换到原始点云下
                        VectorPoint_3rd_trans(hv_HomMat3D, hv_HomMat3D1, hv_HomMat3D2, hv_RightUpPoint1,
                                              &hv_RightUpPoint2);
                        //* 右下角端点变换到原始点云下
                        VectorPoint_3rd_trans(hv_HomMat3D, hv_HomMat3D1, hv_HomMat3D2, hv_RightDownPoint1,
                                              &hv_RightDownPoint2);

                        //*根据实际的3D坐标点，对4组坐标排序
                        hv_PositionX.Clear();
                        hv_PositionX.Append(HTuple(hv_LeftUpPoint2[0]));
                        hv_PositionX.Append(HTuple(hv_LeftDownPoint2[0]));
                        hv_PositionX.Append(HTuple(hv_RightUpPoint2[0]));
                        hv_PositionX.Append(HTuple(hv_RightDownPoint2[0]));
                        hv_PositionY.Clear();
                        hv_PositionY.Append(HTuple(hv_LeftUpPoint2[1]));
                        hv_PositionY.Append(HTuple(hv_LeftDownPoint2[1]));
                        hv_PositionY.Append(HTuple(hv_RightUpPoint2[1]));
                        hv_PositionY.Append(HTuple(hv_RightDownPoint2[1]));
                        hv_PositionZ.Clear();
                        hv_PositionZ.Append(HTuple(hv_LeftUpPoint2[2]));
                        hv_PositionZ.Append(HTuple(hv_LeftDownPoint2[2]));
                        hv_PositionZ.Append(HTuple(hv_RightUpPoint2[2]));
                        hv_PositionZ.Append(HTuple(hv_RightDownPoint2[2]));
                        //**索引判断坐标
                        //*X值小的为上侧点，Y值小的为右侧点
                        TupleSortIndex(hv_PositionY, &hv_Indices);
                        //*则Y大的两个端点为左侧边缘的端点
                        hv_LeftRowCorner.Clear();
                        hv_LeftRowCorner.Append(HTuple(hv_PositionY[HTuple(hv_Indices[2])]));
                        hv_LeftRowCorner.Append(HTuple(hv_PositionY[HTuple(hv_Indices[3])]));
                        hv_LeftColCorner.Clear();
                        hv_LeftColCorner.Append(HTuple(hv_PositionX[HTuple(hv_Indices[2])]));
                        hv_LeftColCorner.Append(HTuple(hv_PositionX[HTuple(hv_Indices[3])]));
                        hv_LeftZCorner.Clear();
                        hv_LeftZCorner.Append(HTuple(hv_PositionZ[HTuple(hv_Indices[2])]));
                        hv_LeftZCorner.Append(HTuple(hv_PositionZ[HTuple(hv_Indices[3])]));
                        //*X值小的为上侧点
                        TupleSortIndex(hv_LeftColCorner, &hv_Indices1);
                        hv_VectorY.Clear();
                        hv_VectorY.Append(HTuple(hv_LeftColCorner[HTuple(hv_Indices1[0])]));
                        hv_VectorY.Append(HTuple(hv_LeftRowCorner[HTuple(hv_Indices1[0])]));
                        hv_VectorY.Append(HTuple(hv_LeftZCorner[HTuple(hv_Indices1[0])]));
                        hv_VectorZ.Clear();
                        hv_VectorZ.Append(HTuple(hv_LeftColCorner[HTuple(hv_Indices1[1])]));
                        hv_VectorZ.Append(HTuple(hv_LeftRowCorner[HTuple(hv_Indices1[1])]));
                        hv_VectorZ.Append(HTuple(hv_LeftZCorner[HTuple(hv_Indices1[1])]));

                        //***则Y小的两个端点为右侧边缘的端点
                        hv_RightRowCorner.Clear();
                        hv_RightRowCorner.Append(HTuple(hv_PositionY[HTuple(hv_Indices[0])]));
                        hv_RightRowCorner.Append(HTuple(hv_PositionY[HTuple(hv_Indices[1])]));
                        hv_RightColCorner.Clear();
                        hv_RightColCorner.Append(HTuple(hv_PositionX[HTuple(hv_Indices[0])]));
                        hv_RightColCorner.Append(HTuple(hv_PositionX[HTuple(hv_Indices[1])]));
                        hv_RightZCorner.Clear();
                        hv_RightZCorner.Append(HTuple(hv_PositionZ[HTuple(hv_Indices[0])]));
                        hv_RightZCorner.Append(HTuple(hv_PositionZ[HTuple(hv_Indices[1])]));
                        //*X值小的为上侧点
                        TupleSortIndex(hv_RightColCorner, &hv_Indices1);
                        hv_RightUpPoint.Clear();
                        hv_RightUpPoint.Append(HTuple(hv_RightColCorner[HTuple(hv_Indices1[0])]));
                        hv_RightUpPoint.Append(HTuple(hv_RightRowCorner[HTuple(hv_Indices1[0])]));
                        hv_RightUpPoint.Append(HTuple(hv_RightZCorner[HTuple(hv_Indices1[0])]));
                        hv_RightDownPoint.Clear();
                        hv_RightDownPoint.Append(HTuple(hv_RightColCorner[HTuple(hv_Indices1[1])]));
                        hv_RightDownPoint.Append(HTuple(hv_RightRowCorner[HTuple(hv_Indices1[1])]));
                        hv_RightDownPoint.Append(HTuple(hv_RightZCorner[HTuple(hv_Indices1[1])]));

                        //*根据3D坐标点，对二维坐标点排序
                        SortCorner(hv_RightUpPoint, hv_RightUpPoint2, hv_RightDownPoint2, hv_LeftUpPoint2,
                                   hv_LeftDownPoint2, hv_RightDown1, hv_RightUp1, hv_LeftUp1, hv_LeftDown1,
                                   &hv_RightUp);
                        SortCorner(hv_RightDownPoint, hv_RightUpPoint2, hv_RightDownPoint2, hv_LeftUpPoint2,
                                   hv_LeftDownPoint2, hv_RightDown1, hv_RightUp1, hv_LeftUp1, hv_LeftDown1,
                                   &hv_RightDown);
                        SortCorner(hv_VectorY, hv_RightUpPoint2, hv_RightDownPoint2, hv_LeftUpPoint2,
                                   hv_LeftDownPoint2, hv_RightDown1, hv_RightUp1, hv_LeftUp1, hv_LeftDown1,
                                   &hv_LeftUp);
                        SortCorner(hv_VectorZ, hv_RightUpPoint2, hv_RightDownPoint2, hv_LeftUpPoint2,
                                   hv_LeftDownPoint2, hv_RightDown1, hv_RightUp1, hv_LeftUp1, hv_LeftDown1,
                                   &hv_LeftDown);

                        //**---------------------------------------------3.2 获取目标区域的边缘点和箱子高度--------------------------------------
                        //*下述三个参数用来显示找点结果
                        hv_MeasureWidth = 0.5;
                        //*根据四个端点坐标计算宽度方向的中心坐标
                        CalCenterLinePoints(hv_LeftUp, hv_LeftDown, hv_RightUp, hv_RightDown, hv_MeasureWidth,
                                            &hv_Rows, &hv_Columns, &hv_tuple_Phi, &hv_tuple_Len1, &hv_tuple_Len2);
                        //*计算高度方向的数值
                        LinePosition(HTuple(hv_RightUp[0]), HTuple(hv_RightUp[1]), HTuple(hv_LeftUp[0]),
                                     HTuple(hv_LeftUp[1]), &hv_UpCenterRow, &hv_UpCenterCol, &hv_LengthU, &hv_PhiU);
                        GenRectangle2(&ho_Rectangle1, hv_UpCenterRow, hv_UpCenterCol, hv_PhiU, hv_LengthU,
                                      5);

                        MeasureHeight(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                      ho_ZResult, ho_Rectangle1, hv_Rows, hv_Columns, hv_tuple_Phi, hv_tuple_Len1,
                                      hv_tuple_Len2, hv_MaxTh, hv_MinTh, &hv_Height3D, &hv_LineUpX1, &hv_LineUpY1,
                                      &hv_LineUpZ1, &hv_LineDownX1, &hv_LineDownY1, &hv_LineDownZ1);
                        TupleMedian(hv_Height3D, &(hv_MedianHeight));

                        //*根据四个端点坐标计算高度方向的中心坐标,角度和长度
                        CalCenterLinePoints(hv_LeftUp, hv_RightUp, hv_LeftDown, hv_RightDown, hv_MeasureWidth,
                                            &hv_Rows1, &hv_Columns1, &hv_tuple_Phi1, &hv_tuple_Len11, &hv_tuple_Len21);
                        //*计算宽度方向的数值
                        LinePosition(HTuple(hv_RightUp[0]), HTuple(hv_RightUp[1]), HTuple(hv_RightDown[0]),
                                     HTuple(hv_RightDown[1]), &hv_RightCenterRow, &hv_RightCenterCol, &hv_LengthR,
                                     &hv_PhiR);
                        GenRectangle2(&ho_Rectangle2, hv_RightCenterRow, hv_RightCenterCol, hv_PhiR,
                                      hv_LengthR, 5);
                        MeasureHeight(ho_RegionFillUp, ho_ImageReduced1, ho_ImageReduced2, ho_ImageReduced3,
                                      ho_ZResult, ho_Rectangle2, hv_Rows1, hv_Columns1, hv_tuple_Phi1, hv_tuple_Len11,
                                      hv_tuple_Len21, hv_MaxTh, hv_MinTh, &hv_Width3D, &hv_LineRightX1, &hv_LineRightY1,
                                      &hv_LineRightZ1, &hv_LineLeftX1, &hv_LineLeftY1, &hv_LineLeftZ1);
                        TupleMedian(hv_Width3D, &(hv_MedianWidth));

                        double Height = hv_MedianHeight[0].D();
                        double Width = hv_MedianWidth[0].D();
                        MedianWidth = Width;
                        MedianHeight = Height;
                        //***将坐标变换到原始3D模型下
                        VectorPoints_3rd_trans(hv_LineUpX1, hv_LineUpY1, hv_LineUpZ1, hv_HomMat3D, hv_HomMat3D1,
                                               hv_HomMat3D2, &hv_LineUpX, &hv_LineUpY, &hv_LineUpZ);
                        VectorPoints_3rd_trans(hv_LineDownX1, hv_LineDownY1, hv_LineDownZ1, hv_HomMat3D,
                                               hv_HomMat3D1, hv_HomMat3D2, &hv_LineDownX, &hv_LineDownY, &hv_LineDownZ);
                        VectorPoints_3rd_trans(hv_LineLeftX1, hv_LineLeftY1, hv_LineLeftZ1, hv_HomMat3D,
                                               hv_HomMat3D1, hv_HomMat3D2, &hv_LineLeftX, &hv_LineLeftY, &hv_LineLeftZ);
                        VectorPoints_3rd_trans(hv_LineRightX1, hv_LineRightY1, hv_LineRightZ1, hv_HomMat3D,
                                               hv_HomMat3D1, hv_HomMat3D2, &hv_LineRightX, &hv_LineRightY, &hv_LineRightZ);

                        //*3D直线拟合
                        FitLine3D(hv_LineUpX, hv_LineUpY, hv_LineUpZ, &hv_MeanPointUp, &hv_lineVecUp);
                        FitLine3D(hv_LineDownX, hv_LineDownY, hv_LineDownZ, &hv_MeanPointDown, &hv_lineVecDown);
                        FitLine3D(hv_LineLeftX, hv_LineLeftY, hv_LineLeftZ, &hv_MeanPointLeft, &hv_lineVecLeft);
                        FitLine3D(hv_LineRightX, hv_LineRightY, hv_LineRightZ, &hv_MeanPointRight, &hv_lineVecRight);

                        HTuple hv_AngleUR, hv_AngleDR, hv_AngleUL, hv_AngleDL;
                        Line3D_Angle(hv_lineVecRight, hv_lineVecUp, &hv_AngleUR);
                        Line3D_Angle(hv_lineVecRight, hv_lineVecDown, &hv_AngleDR);
                        Line3D_Angle(hv_lineVecLeft, hv_lineVecUp, &hv_AngleUL);
                        Line3D_Angle(hv_lineVecLeft, hv_lineVecDown, &hv_AngleDL);

                        if (0 != (HTuple(HTuple(HTuple(int(((hv_AngleUR - 90).TupleAbs()) < 10)).TupleOr(int(((hv_AngleDR - 90).TupleAbs()) < 10))).TupleOr(int(((hv_AngleUL - 90).TupleAbs()) < 10))).TupleOr(int(((hv_AngleDL - 90).TupleAbs()) < 10))))
                        {
                            Result = "-1, 直线拟合结果异常，请确认";
                            return;
                        }
                        else
                        {
                            //*根据空间点到直线的距离判断直线质量
                            LineQuality_3D(hv_LineUpX, hv_LineUpY, hv_LineUpZ, hv_MeanPointUp, hv_lineVecUp,
                                           &hv_DistUp, &hv_MedianUp, &hv_DeviationUp);
                            LineQuality_3D(hv_LineDownX, hv_LineDownY, hv_LineDownZ, hv_MeanPointDown, hv_lineVecDown,
                                           &hv_DistDown, &hv_MedianDown, &hv_DeviationDown);
                            LineQuality_3D(hv_LineRightX, hv_LineRightY, hv_LineRightZ, hv_MeanPointRight,
                                           hv_lineVecRight, &hv_DistRight, &hv_MedianRight, &hv_DeviationRight);
                            LineQuality_3D(hv_LineLeftX, hv_LineLeftY, hv_LineLeftZ, hv_MeanPointLeft, hv_lineVecLeft,
                                           &hv_DistLeft, &hv_MedianLeft, &hv_DeviationLeft);

                            double deviUp = hv_DeviationUp[0].D();
                            double deviDown = hv_DeviationDown[0].D();
                            double deviRight = hv_DeviationRight[0].D();
                            double deviLeft = hv_DeviationLeft[0].D();
                            LineQuali[0] = deviUp;
                            LineQuali[1] = deviDown;
                            LineQuali[2] = deviRight;
                            LineQuali[3] = deviLeft;

                            hv_DeviaDis.Clear();
                            hv_DeviaDis.Append(hv_DeviationUp);
                            hv_DeviaDis.Append(hv_DeviationDown);
                            hv_DeviaDis.Append(hv_DeviationRight);
                            TupleSortIndex(hv_DeviaDis, &hv_Indices2);
                            hv_Line = "Right";
                            if (0 != (int(HTuple(hv_Indices2[0]) == 0)))
                            {
                                hv_Line = "Up";
                            }
                            else if (0 != (int(HTuple(hv_Indices2[0]) == 1)))
                            {
                                hv_Line = "Down";
                            }
                            else
                            {
                                hv_Line = "Right";
                            }
                            //*

                            //*计算两条三维直线的交点
                            LineIntersec3D(hv_MeanPointUp, hv_lineVecUp, hv_MeanPointRight, hv_lineVecRight,
                                           &hv_RightPoint, &(Result1));
                            if (Result1 == -1)
                            {
                                Result = "-1, 两个直线平行或重合，请确认";
                                return;
                            }

                            LineIntersec3D(hv_MeanPointUp, hv_lineVecUp, hv_MeanPointLeft, hv_lineVecLeft,
                                           &hv_IntersecPonitUL, &(Result1));
                            if (Result1 == -1)
                            {
                                Result = "-1, 两个直线平行或重合，请确认";
                                return;
                            }

                            LineIntersec3D(hv_MeanPointDown, hv_lineVecDown, hv_MeanPointRight, hv_lineVecRight,
                                           &hv_IntersecPonitDR, &(Result1));
                            if (Result1 == -1)
                            {
                                Result = "-1, 两个直线平行或重合，请确认";
                                return;
                            }

                            LineIntersec3D(hv_MeanPointDown, hv_lineVecDown, hv_MeanPointLeft, hv_lineVecLeft,
                                           &hv_IntersecPonitDL, &(Result1));
                            if (Result1 == -1)
                            {
                                Result = "-1, 两个直线平行或重合，请确认";
                                return;
                            }
                            double *PonitUR = hv_RightPoint.ToDArr();
                            double *PonitUL = hv_IntersecPonitUL.ToDArr();
                            double *PonitDR = hv_IntersecPonitDR.ToDArr();
                            double *PonitDL = hv_IntersecPonitDL.ToDArr();

                            IntersecPonitUR[0] = PonitUR[0];
                            IntersecPonitUR[1] = PonitUR[1];
                            IntersecPonitUR[2] = PonitUR[2];
                            IntersecPonitUL[0] = PonitUL[0];
                            IntersecPonitUL[1] = PonitUL[1];
                            IntersecPonitUL[2] = PonitUL[2];

                            IntersecPonitDR[0] = PonitDR[0];
                            IntersecPonitDR[1] = PonitDR[1];
                            IntersecPonitDR[2] = PonitDR[2];
                            IntersecPonitDL[0] = PonitDL[0];
                            IntersecPonitDL[1] = PonitDL[1];
                            IntersecPonitDL[2] = PonitDL[2];

                            //*-----------------------------根据右侧棱和法向量计算坐标系另一方向
                            if (0 != (int(hv_Line == HTuple("Right"))))
                            {
                                CrossMultFunc(hv_lineVecRight, hv_VectorX, &hv_VectorY2);
                                //**单位化法向量:实际为箱体X轴方向
                                UnitVector(hv_VectorX, ((HTuple(0).Append(0)).Append(0)), &hv_VectorX);
                                UnitVector(hv_VectorY2, ((HTuple(0).Append(0)).Append(0)), &hv_VectorY);
                                //*叉乘计算
                                CrossMultFunc(hv_VectorX, hv_VectorY, &hv_VectorZ1);
                                UnitVector(hv_VectorZ1, ((HTuple(0).Append(0)).Append(0)), &hv_VectorZ);
                            }
                            else if (0 != (int(hv_Line == HTuple("Up"))))
                            {
                                CrossMultFunc(hv_lineVecUp, hv_VectorX, &hv_VectorZ2);
                                //**单位化法向量:实际为箱体X轴方向
                                UnitVector(hv_VectorX, ((HTuple(0).Append(0)).Append(0)), &hv_VectorX);
                                UnitVector(hv_VectorZ2, ((HTuple(0).Append(0)).Append(0)), &hv_VectorZ);
                                //*叉乘计算
                                CrossMultFunc(hv_VectorX, hv_VectorZ, &hv_VectorY1);
                                UnitVector(hv_VectorY1, ((HTuple(0).Append(0)).Append(0)), &hv_VectorY);
                            }
                            else if (0 != (int(hv_Line == HTuple("Down"))))
                            {
                                CrossMultFunc(hv_lineVecDown, hv_VectorX, &hv_VectorZ2);
                                //**单位化法向量:实际为箱体X轴方向
                                UnitVector(hv_VectorX, ((HTuple(0).Append(0)).Append(0)), &hv_VectorX);
                                UnitVector(hv_VectorZ2, ((HTuple(0).Append(0)).Append(0)), &hv_VectorZ);
                                //*叉乘计算
                                CrossMultFunc(hv_VectorX, hv_VectorZ, &hv_VectorY1);
                                UnitVector(hv_VectorY1, ((HTuple(0).Append(0)).Append(0)), &hv_VectorY);
                            }
                            else if (0 != (int(hv_Line == HTuple("Left"))))
                            {
                                CrossMultFunc(hv_lineVecRight, hv_VectorX, &hv_VectorY2);
                                //**单位化法向量:实际为箱体X轴方向
                                UnitVector(hv_VectorX, ((HTuple(0).Append(0)).Append(0)), &hv_VectorX);
                                UnitVector(hv_VectorY2, ((HTuple(0).Append(0)).Append(0)), &hv_VectorY);
                                //*叉乘计算
                                CrossMultFunc(hv_VectorX, hv_VectorY, &hv_VectorZ1);
                                UnitVector(hv_VectorZ1, ((HTuple(0).Append(0)).Append(0)), &hv_VectorZ);
                            }
                            if (0 != (int(HTuple(hv_VectorX[2]) > 0)))
                            {
                                hv_VectorX = -hv_VectorX;
                            }
                            if (0 != (int(HTuple(hv_VectorY[1]) > 0)))
                            {
                                hv_VectorY = -hv_VectorY;
                            }
                            if (0 != (int(HTuple(hv_VectorZ[0]) > 0)))
                            {
                                hv_VectorZ = -hv_VectorZ;
                            }

                            double *X = hv_VectorX.ToDArr();
                            double *Y = hv_VectorY.ToDArr();
                            double *Z = hv_VectorZ.ToDArr();
                            VectorPosition[0] = X[0];
                            VectorPosition[1] = X[1];
                            VectorPosition[2] = X[2];

                            VectorPosition[3] = Y[0];
                            VectorPosition[4] = Y[1];
                            VectorPosition[5] = Y[2];

                            VectorPosition[6] = Z[0];
                            VectorPosition[7] = Z[1];
                            VectorPosition[8] = Z[2];
                            Result = "1, 运行成功";
                            // VectorPosition={X[0], X[1], X[2], Y[0], Y[1], Y[2], Z[0], Z[1], Z[2]};
                        }
                    }
                    else
                    {
                        Result = "-1, 调平的目标点云区域为空";
                    }
                }

                else
                {
                    Result = "-1, 目标点云区域数量不对";
                }
            }
            else
            {
                Result = "-1, 未提取出箱体";
            }
        }
        catch (HException &HDevExpDefaultException)
        {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            Result = "-1, 程序运行异常";
        }
        return;
    }

} // namespace PCLlibs